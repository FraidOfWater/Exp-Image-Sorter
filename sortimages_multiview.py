#pip freeze > requirements.txt && pip uninstall -r requirements.txt -y && del requirements.txt

import os
import json
import logging

from shutil import rmtree, move as shutilmove

from random import seed, random
from time import perf_counter

from threading import Thread
from concurrent.futures import ThreadPoolExecutor
from gc import collect

from hashlib import md5
from PIL import Image, ImageTk
from imageio import get_reader, mimread

import tkinter as tk
from tkinter.messagebox import askokcancel
from tkinter import filedialog as tkFileDialog

import numpy as np

from gui import GUIManager
from navigator import Navigator

def import_pyvips():
    "This looks scary, but it just points to where 'import pyvips' can find it's files from"
    "To update this module, change vips-dev-8.16 to your new folder name here and in build.bat"
    base_path = os.path.dirname(os.path.abspath(__file__))
    vipsbin = os.path.join(base_path, "vips-dev-8.16", "bin")
    
    if not os.path.exists(vipsbin):
        raise FileNotFoundError(f"The directory {vipsbin} does not exist.")

    os.environ['PATH'] = os.pathsep.join((vipsbin, os.environ['PATH']))
    os.add_dll_directory(vipsbin)
import_pyvips()
try:
    import pyvips
except Exception as e:
    print("Couldn't import pyvips:", e)

logger = logging.getLogger("Sortimages")
logger.setLevel(logging.WARNING)  # Set to the lowest level you want to handle
handler = logging.StreamHandler()
handler.setLevel(logging.WARNING)
formatter = logging.Formatter('%(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)

" Long-term Polish "
# Replace while loops with better program exit checking. While does not apparently check the if for every line, but for every loop.
# This has caused clutter/complexity in gen_frames.
# To fix frame limiter, figure out framecount first and choose to allow loading upon that.
# Sometimes frames animate on 1 or two frames.
# Some kind of memory leak exists when sorting for a while. 
# Seems like canvasimage destroy() breaks or something. Large delays. memory increase. Fixed?

" Known issues "
# Phantom shutdowns every once in a while. Reason unclear. (Was it the threads not shutting down bug? Sometimes I got thread unsynch thing. Not in sequence and such. Out of sequence)
"Memory"
# Fail to allocate bitmap memory issue. Tkinter or PIL cant juggle a lot of animated images at the same time. Load less of them.
# Use self.max_concurrent_frames = 5000 to set memory limit and lower self.threads if you lag.
"Memory leaks"
# If memory leaks persist (by fast changing of gridsquares in viewers), objgraph growth shows creation of 1 addition to list and 1 frame.
# The 1 addition to list is tkinter window hierarchy, cant change that. 1 frame is likely that 1 frame added to the list. Destviewr also creates this hierarchy clutter.
#Leak is negligible now, so won't bother. Cannot delete tkinter window hierarchy, rather, have one image_frame and update contents. 

class Imagefile:
    path = "" # Once move happens, this becomes dest, dest = "" and moved flag becomes True".
    dest = "" # Moved imgs have flag moved = True and dest = "", Assigned images have dest = "path"

    def __init__(self, name, path, ext) -> None:
        "An Imagefile object stores data about the image to help us manage it in the program"
        "Normal attributes"
        self.name = name
        self.truncated_filename = "..." # This is just a placeholder for destination destsquare truncated name. We copy it over from gridsquare and dont have to generate it again.
        self.path = path
        self.moved = False              # Used to track if img is sorted
        self.checked = tk.BooleanVar(value=False) # Checkbox checked or not.
        self.ext = ext
        
        "Hash"
        self.id = None              # Hash of img name, mod_time and file_size. This is faster to hash than whole file binary stream.
        self.mod_time = None        # Used by sortimages. Used to hash id.
        self.file_size = None       # Used by canvasimage. Buffers if large enough. Used to hash id.

        "Animation"
        self.lazy_loading = True    # Used to tell animate to stop lazy loading animation and move to actual loop.
        self.frames = None          # PIL frames for animation with tkinter for imagegrid. Generated by ThumbManager (self.animate) for gif, webp and webm.
        self.frametimes = None      # Used for animating at correct speed. Generated by thumbmanager.generate.
        self.framecount = 0         # could use len(frames) instead? ###
        self.index = 0              # Used to control what frame is displayed (for imgagegrid).
        self.delay = 100            #Default delay. Used to fill frametimes if speed can't be extracted from file.

        "Canvasimage, video support"
        self.dimensions = None      # Used by canvasimage. VLC must know aspect ratio.

    def setdest(self, dest) -> None:
        "Sets imagefile dest and destcolor to desired."
        self.dest = dest["path"]
        self.dest_color = dest["color"]
        logger.info("Set destination of %s to %s", self.name, self.dest)

    def rename(self, name, fileManager):
        new_path = f"{self.path[:-len(self.name)]}{name}"
        os.rename(self.path, new_path)
        self.path = new_path
        self.name = name
        self.truncated_filename = fileManager.thumbs.truncate_text(self)
        frame = self.guidata["frame"]
        frame.obj2.set(self.truncated_filename)
        fileManager.gui.displayimage(fileManager.navigator.select(fileManager.navigator.old))

    def move(self, fileManager) -> None:
        "Move image from self.path to self.dest and set self.dest = ''. Turn moved flag to True"

        "Early exits"
        if not self.dest: # dest = ""
            return
        if not os.path.isdir(self.dest): # If dest exists but not found in file system
            return

        "Pointers"
        filename = self.name # in function, better to point  like this or call each time? ###
        old_path = self.path + "" # Perhaps unnecessary, if shutil fails, self.path wont get set to destpath. This is for clarity. This is original path of the file.
        destpath = os.path.join(self.dest, filename)

        "Check for conflicts: file with same name already in dest." "Refuse to overwrite anything"
        if os.path.exists(destpath): # path/to/dest/filename
            print(f"File {filename[:30]} already exists in destination. No action")
            if self.path == destpath:
                return True
            return False

        try:
            shutilmove(self.path, destpath) # Copy -> Delete. If either fail, do exceptions.
            
            #self.guidata["frame"].configure(
            #    highlightbackground="green", highlightthickness=2)

            self.path = destpath
            self.dest = ""
            self.moved = True

            
            return True
        except Exception as e:
            "Shutil failed: Did delete old fail?"
            if os.path.exists(destpath) and os.path.exists(old_path): # This can only remove files created by shutil due to our early exits checking for anything in the way. Safe.
                os.remove(destpath)
                print(f"File {filename[:30]} is in use and is unable to delete. Removing created copy from destination.")
                return 
            else:
                print(f"Error moving/deleting: {e} {filename[:30]}, This error shouldn't be raised at all. Report/investigate")
            #self.guidata["frame"].configure(highlightbackground="red", highlightthickness=2) # Notify user via gui if we get exceptions.
            return False

class SortImages:
    imagelist = [] # Store all Imagefiles
    destinations = []
    exclude = []
    program_is_exiting = False
    def __init__(self) -> None:
        "Sortimages setups the program. It creates imagefiles from the folder given, loads and saves prefs, loads and saves sessions, and starts up the gui and other modules."
        "Paths"
        script_dir = os.path.dirname(os.path.abspath(__file__))
        self.data_dir = os.path.join(script_dir, "data")
        self.prefs_path = os.path.join(os.getcwd(), "prefs.json")
        self.themes_path = os.path.join(os.getcwd(), "themes.json")

        self.jthemes = None
        self.load_themes()

        "Timekeeping and throttling"
        self.timer = Timer()        # Time since creation.
        self.last_call_time = 0     # Used to throttle setdestination against too frequent calls
        self.throttle_delay = 0.19

        "Normal attributes"
        self.autosave=True
        self.threads = 4 # Roughly how much computing power you use. Thumbs use twice this amount, frames half.
        self.max_concurrent_frames = 6000 #6200 # memory overflow / bitmap allocation fix. Too many tkinter animations will crash the program. Use this to limit the amount of frames in memory.
        self.animation_queue = []
        "Start modules"
        self.gui = GUIManager(self) # loadprefs() edits self.gui attributes. Create self.gui and attributes for loadprefs() to manipulate.
        self.loadprefs()            # Load prefs
        self.gui.initialize()       # Let GUI initialize fully now with loaded values.

        self.navigator = Navigator(self) # Navigator highlights the current selection, main use is to be able to navigate using arrow or wasd keys ### (wasd not implemented)
        self.animate = Animate(self, self.gui.square_default) # Animate module is dedicated for making things animated.
        self.thumbs = ThumbManager(self) # Thumbmanager generates thumbs, frames, truncated names and imagefile attributes, and reloads and unloads resources when needed.
        
        self.gui.destination_viewer.set_thumbmanager_and_animate()

        self.gui.change_theme(self.gui.theme.get())

        self.gui.show_ram_usage()

        self.validate_thumbnail_cache()
        self.gui.mainloop()

    def validate_thumbnail_cache(self):
        "Setups cache folder for thumbnails. If folder doesn't exist, it is created. If the first picture in it is not the expected size, the folder is emptied."

        "Pointers"
        data_dir = self.data_dir

        "Data folder doesn't exists: creates it"
        if not (os.path.exists(data_dir) and os.path.isdir(data_dir)):
            logger.warning(f"Data folder created")
            os.mkdir(data_dir)
            return

        "Data folder exists: do nothing if empty"
        cache = os.listdir(data_dir)
        if len(cache) < 1:
            logger.warning(f"Data folder is empty")
            return

        "Data folder not empty: empty folder if first file name is wrong"
        if not cache[0].lower().endswith('.webp'):
            try:
                logger.warning(f"Removing data folder, first file inspected wasn't .jpg")
                rmtree(data_dir)
                os.mkdir(data_dir)
                logger.warning(f"Re-created data folder.")
            except Exception as e:
                print(f"Couldn't delete/create data folder: {e}")
            return
        
        "First image found, check whether it is the expected size (prefs.json thumbnailsize)"
        first_image_path = os.path.join(data_dir, cache[0])
        try:
            image = pyvips.Image.new_from_file(first_image_path, access='sequential') # Should be robust, these images are create by PIL or pyvips themselves.
            if max(image.width, image.height) != self.gui.thumbnailsize: # The larger side doesn't equal thumbnailsize in prefs.json, meaning user changed this setting.
                try:
                    logger.warning(f"Removing data folder, thumbnailsize changed")
                    rmtree(data_dir)
                    os.mkdir(data_dir)
                    logger.warning(f"Re-created data folder.")
                except Exception as e:
                    print(f"Couldn't delete/create data folder: {e}")
        except Exception as e:
            logger.error(f"Couldn't load first image in data folder {e}")
        finally:
            del image
       
    def loadprefs(self):
        "Loads prefs.json. Needs self.gui to be created. This edits self.gui attributes."
        gui = self.gui
        hotkeys = "" # manual checking at end of this method

        try:
            with open(self.prefs_path, "r") as prefsfile:

                jdata = prefsfile.read()
                jprefs = json.loads(jdata)

                "Paths"
                gui.source_folder = jprefs["paths"]["source"]
                gui.destination_folder = jprefs["paths"]["destination"]
                gui.sessionpathvar.set(jprefs["paths"]['lastsession'])
                self.exclude = jprefs["paths"]["exclude"]
        
                "Preferences"
                gui.thumbnailsize = int(jprefs["preferences"]["user"]["thumbnailsize"])
                hotkeys = jprefs["preferences"]["user"]["hotkeys"]
                gui.centering_button = jprefs["preferences"]["user"]["centering_button"]
                gui.force_scrollbar = jprefs["preferences"]["user"]["force_scrollbar"]
                gui.auto_load = jprefs["preferences"]["user"]["auto_load"]
                gui.do_anim_loading_colors = jprefs["preferences"]["user"]["do_anim_loading_colors"]
                gui.do_debug_terminal = jprefs["preferences"]["user"]["do_debug_terminal"]

                "Technical preferences"
                gui.filter_mode = jprefs["preferences"]["technical"]["quick_preview_filter"]
                gui.quick_preview_size_threshold = int(jprefs["preferences"]["technical"]["quick_preview_size_threshold"])
                self.threads = jprefs["preferences"]["technical"]['threads']
                self.max_concurrent_frames = int(jprefs["preferences"]["technical"]['max_concurrent_frames'])
                self.autosave = jprefs["preferences"]["technical"]['autosave_session']

                "GUI CONTROLLED PREFRENECES"
                gui.squares_per_page_intvar.set(jprefs["qui"]["squares_per_page"])
                gui.sort_by_date_boolvar.set(jprefs["qui"]["sort_by_date"])
                gui.viewer_x_centering = jprefs["qui"]["viewer_x_centering"]
                gui.viewer_y_centering = jprefs["qui"]["viewer_y_centering"]
                gui.show_next.set(jprefs["qui"]["show_next"])
                gui.dock_view.set(jprefs["qui"]["dock_view"])
                gui.dock_side.set(jprefs["qui"]["dock_side"])
                gui.theme.set(jprefs["qui"]["theme"])

                "Window positions"
                gui.main_geometry = jprefs["window_settings"]["main_geometry"]
                gui.viewer_geometry = jprefs["window_settings"]["viewer_geometry"]
                gui.destpane_geometry = jprefs["window_settings"]["destpane_geometry"]
                gui.leftpane_width = int(jprefs["window_settings"]["leftpane_width"])
                gui.middlepane_width = int(jprefs["window_settings"]["middlepane_width"])
                gui.images_sorted.set(str(jprefs["window_settings"]["images_sorted"]))
                gui.images_sorted_strvar.set(f"Sorted: {gui.images_sorted.get()}")
                gui.actual_gridsquare_width = gui.thumbnailsize + gui.gridsquare_padx + gui.square_border_size*2 + gui.whole_box_size*2
                gui.actual_gridsquare_height = gui.thumbnailsize + gui.gridsquare_pady + gui.square_border_size*2 + gui.whole_box_size*2 + gui.checkbox_height

            if len(hotkeys) > 1:
                gui.hotkeys = hotkeys

            "Make sure middlepane doesnt become 'hidden', fooled me!"
            "If the thumbnail grid becomes too small, reset it to an acceptable size."
            win_width, discard = gui.main_geometry.split("x")
            win_width = int(win_width)
            l_pan = gui.leftpane_width
            m_pan = gui.middlepane_width
            if win_width - l_pan-m_pan < gui.thumbnailsize+35:
                space = int(win_width) - int(gui.leftpane_width)
                gui.middlepane_width = space-gui.thumbnailsize-35

        except Exception as e:
            logger.error(f"Error loading prefs.json: {e}")
    def saveprefs(self, gui):
        "Saves all customizable stuff to prefs.json."
        if gui.middlepane_frame.winfo_width() == 1: # Do not try to save invalid value
            pass
        else:
            gui.middlepane_width = gui.middlepane_frame.winfo_width()

        sdp = gui.source_entry_field.get() if os.path.exists(gui.source_entry_field.get()) else ""
        ddp = gui.destination_entry_field.get() if os.path.exists(gui.destination_entry_field.get()) else ""

        temp = gui.squares_per_page_intvar.get()
        if temp == "": # if field left empty
            temp = 1
        save = {
            "paths": {
                "source": sdp,
                "destination": ddp,
                "lastsession": gui.sessionpathvar.get(),
                "exclude": self.exclude,
            },
            "preferences": {
                "user": {
                    "thumbnailsize": gui.thumbnailsize,
                    "hotkeys": gui.hotkeys,
                    "centering_button": gui.centering_button,
                    "force_scrollbar": gui.force_scrollbar,
                    "auto_load": gui.auto_load,
                    "do_anim_loading_colors": gui.do_anim_loading_colors,
                    "do_debug_terminal": gui.do_debug_terminal
                },
                "technical": {
                    "quick_preview_filter": gui.filter_mode,
                    "quick_preview_size_threshold": gui.quick_preview_size_threshold,
                    "threads": self.threads,
                    "max_concurrent_frames": self.max_concurrent_frames,
                    "autosave_session":self.autosave,
                },
            },
            "qui": {
                "squares_per_page": gui.squares_per_page_intvar.get(),
                "sort_by_date": gui.sort_by_date_boolvar.get(),
                "viewer_x_centering": gui.viewer_x_centering,
                "viewer_y_centering": gui.viewer_y_centering,
                "show_next": gui.show_next.get(),
                "dock_view": gui.dock_view.get(),
                "dock_side": gui.dock_side.get(),
                "theme": gui.theme.get(),
            },
            "window_settings": {
                "main_geometry": gui.winfo_geometry(),
                "viewer_geometry": gui.viewer_geometry,
                "destpane_geometry":gui.destpane_geometry,
                "leftpane_width":gui.leftui.winfo_width(),
                "middlepane_width":gui.middlepane_width,
                "images_sorted":gui.images_sorted.get(),
            },
        }

        "Save to prefs.json"
        try:
            with open(self.prefs_path, "w+") as json_file:
                json.dump(save, json_file, indent=4)
                logger.debug(save)
        except Exception as e:
            logger.error(("Failed to save prefs:", e))

        "Save session"
        try:
            if self.autosave:
                self.savesession(asksavelocation=False)
        except Exception as e:
            logger.error(("Failed to save session:", e))
    def savesession(self,asksavelocation):
        gui = self.gui
        "Saves session. Includes some imagefile data and assigned list ids. Sessions do not support thumbnail_cache_validation. So you cannot change thumbnailsize during one."

        "If there is nothing to save"
        if len(self.imagelist) < 1 and len(self.gui.gridmanager.gridsquarelist) < 1:
            return

        "Prompt"
        if asksavelocation:
            filet=[("Javascript Object Notation","*.json")]
            savelocation=tkFileDialog.asksaveasfilename(confirmoverwrite=True,defaultextension=filet,filetypes=filet,initialdir=os.getcwd(),initialfile=gui.sessionpathvar.get())
        else:
            savelocation = gui.sessionpathvar.get()
        
        "Construct save file"
        "Save imagefile attributes"
        def make_list(squares, is_gridsquare=False):
            imagesavedata = []
            for obj in squares:

                name = obj.name
                imagesavedata.append({
                    "name": name,
                    "file_size": obj.file_size,
                    "id": obj.id,
                    "path": obj.path[:-len(name)],
                    })

                if is_gridsquare:
                    if obj.dest != "":
                        imagesavedata[-1]["dest"] = obj.dest
                    if obj.moved == True:
                        imagesavedata[-1]["moved"] = obj.moved

                if hasattr(obj, "dimensions"):
                    if obj.dimensions != None:
                        imagesavedata[-1]["dimensions"] = obj.dimensions
            return imagesavedata

        objs = [x for x in self.imagelist if not x.id or not x.moved or not x.dest]
        imagelist = make_list(objs)

        gridobjs = [x.obj for x in gui.gridmanager.gridsquarelist]
        gridsquarelist = make_list(gridobjs, is_gridsquare=True)

        "We save the order of the assigned list"
        if self.gui.sort_by_date_boolvar.get():
            order = "modification_date"
        else:
            order = "default"
        
        save = {"dest": self.ddp, "source": self.sdp, "thumbnailsize":gui.thumbnailsize, "sortorder": order,
                "imagelist": imagelist, "gridsquarelist": gridsquarelist}
    
        with open(savelocation, "w+") as json_file:
            json.dump(save, json_file, indent=4)    
    
    def loadsession(self):
        gui = self.gui
        gridmanager = gui.gridmanager
        "Loads session"
        sessionpath = gui.sessionpathvar.get()

        "If there is no last session, early exit"
        if not (os.path.exists(sessionpath) and os.path.isfile(sessionpath)):
            logger.warning("No Last Session!")
            return
        
        with open(sessionpath, "r") as json_file:
            sdata = json_file.read()
            savedata = json.loads(sdata)

        gui.thumbnailsize=savedata['thumbnailsize']

        self.sdp = savedata['source']
        self.ddp = savedata['dest']

        self.setup(savedata['dest'])
        gui.guisetup(self.destinations)
        gui.initial_dock_setup()

        print("")
        print(f'Using session:  "{sessionpath}"')
        print(f'Source:   "{self.sdp}"')
        print(f'Target:   "{self.ddp}"')

        "Load imagefiles and imagelists from session.json"
        def make_list(lista, lista_name):
            for line in savedata[lista_name]:
                name = line['name']
                full_path = line['path']+name
                if os.path.exists(full_path):
                    obj = Imagefile(name, full_path, os.path.splitext(name)[1][1:].lower())
                    if line['id']: # If None, (thumb never generated, skip it (processes the imagelist))
                        obj.thumbnail = self.data_dir + "\\" + line['id'] + ".webp"
                    obj.dest=line.get("dest")
                    if obj.dest == None: obj.dest = ""
                    obj.id=line['id']
                    obj.file_size=line['file_size']
                    obj.moved = line.get("moved")
                    if obj.moved == None: obj.moved = False
                    dimensions = line.get('dimensions')
                    if dimensions != None:
                        obj.dimensions=(int(dimensions[0]), int(dimensions[1]))

                    lista.append(obj) # clear of moved and dest.
        gridsquarelist = []
        make_list(self.imagelist, "imagelist")
        make_list(gridsquarelist, "gridsquarelist")
        moved_or_assigned = []
        unassigned = []
        for x in gridsquarelist:
            if x.moved or x.dest:
                moved_or_assigned.append(x)
            else:
                unassigned.append(x)
            
        "Sort order"
        old_order = savedata["sortorder"]
        new_order = self.gui.sort_by_date_boolvar.get()

        if new_order:
            new_order = "modification_date"
        else: 
            new_order = "default"

        if old_order != new_order:
            if new_order == "default":
                self.imagelist.sort(key=lambda img: (img.name, img.path), reverse=True)
                unassigned.sort(key=lambda img: (img.name, img.path))
                change_order = "default"
            else:
                self.imagelist.sort(key=lambda img: os.path.getmtime(img.path), reverse=False)
                unassigned.sort(key=lambda img: os.path.getmtime(img.path), reverse=False)

                change_order = "modification_date"
        else:
            change_order = None

        gui.gridmanager.load_session(unassigned, moved_or_assigned, change_order) 
        gui.destination_viewer.get_paths()

        self.gui.images_left_stats_strvar.set(
            f"Left: {len(gridmanager.assigned)}/{len(gridmanager.gridsquarelist)-len(gridmanager.assigned)-len(gridmanager.moved)}/{len(self.imagelist)}")
 
        gui.images_sorted_strvar.set(f"Sorted: {gui.images_sorted.get()}")
    
    def load_themes(self):
        with open(self.themes_path, "r") as themesfile:
            jdata = themesfile.read()
            jthemes = json.loads(jdata)
            self.jthemes = jthemes

    def moveall(self):
        self.timer.start()
        gui = self.gui
        gridmanager = gui.gridmanager
        temp = gui.gridmanager.assigned.copy()
        reopen = "none"
        old = None
        if hasattr(gui, "second_window") and hasattr(gui, "Image_frame"):
            old = gui.Image_frame.obj
            gui.middlepane_frame.grid_forget()
            gui.Image_frame.destroy()
            gui.unbind("<Configure>")
            del gui.Image_frame
            reopen = "window"
        elif hasattr(gui, "Image_frame"):
            old = gui.Image_frame.obj
            gui.middlepane_frame.grid_forget()
            gui.Image_frame.destroy()
            gui.unbind("<Configure>")
            del gui.Image_frame
            reopen = "dock"

        successfull = []
        for x in temp:
            success = x.obj.move(self)
            if success: # If move was successfull
                gui.gridmanager.assigned.remove(x)
                gui.gridmanager.moved.append(x)
                self.gui.images_left_stats_strvar.set(
                    f"Left: {len(gridmanager.assigned)}/{len(gridmanager.gridsquarelist)-len(gridmanager.assigned)-len(gridmanager.moved)}/{len(self.imagelist)}")
                gui.images_sorted.set(gui.images_sorted.get()+1)
                gui.images_sorted_strvar.set(f"Sorted: {gui.images_sorted.get()}")
                successfull.append(x)
        gui.gridmanager.remove_squares(successfull, unload=True)

        
        if reopen == "window":
            gui.displayimage(old)
        elif reopen =="dock":
            gui.displayimage(old)
        print(self.timer.stop())
    def setDestination(self, *args):
        gui = self.gui
        gridmanager = gui.gridmanager
        current_time = perf_counter()
        #throttling
        if current_time - self.last_call_time < 0.1: #and key pressed down... so you can tap as fast as you like.
            return
            
        else:
            self.last_call_time = current_time
            

        #take multiple
        dest = args[0]

        try:
            wid = args[1].widget
        except AttributeError:
            wid = args[1]["widget"]
        if isinstance(wid, tk.Entry):
            pass

        # Return all images whose checkbox is checked (And currently in view by image viewer, so you can just press a hotkey and not have to check a checkbox everytime) (If interacting with other squares, it will cancel itself out. This is so user wont accidentally move anything.)
        else:
            marked = [] # List of all marked
            
            displayedlist = gridmanager.displayedlist
            marked = [x for x in displayedlist if x.obj.checked.get()]
            if hasattr(gui.destination_viewer, "destwindow"):
                displayedset = gridmanager.displayedset.union(gui.destination_viewer.displayedset)
                displayedlist_dest = gui.destination_viewer.displayedlist
                temp = [x for x in displayedlist_dest if x.obj.checked.get()]
                marked.extend(temp)
            else:
                displayedset = gridmanager.displayedset # Current list being compared

            "Current selection is added to marked if focus never lost"
            if self.navigator.old and gui.focused_on_secondwindow and self.navigator.old in displayedset: # to see if we have clicked elsewhere as to not move the displayed image anymore.
                if self.navigator.old not in marked:
                    marked.append(self.navigator.old)
            
            if not marked:
                return
            if self.gui.focused_on_field:
                return

            #Handle lists
            to_remove_from_grid = []
            to_refresh_from_grid = []
            remove = []
            add = []
            for x in marked: #set background to button colour
                x.obj.setdest(dest)
                temp = x.obj.guidata.get("frame", None)
                if temp:
                    temp['background'] = dest['color']
                    x.obj.guidata["canvas"]['background'] = dest['color']
                x.obj.checked.set(False)


                if hasattr(gui.destination_viewer, "destwindow"):
                    
                    if gui.destination_viewer.dest_path != x.obj.dest: # GRIDSQUARE is not DESTINED to DESTGRID.
                        if x.obj.id in gui.destination_viewer.displayedlist_ids: # GRIDSQUARE ALREAD IN DESTGRID
                            a = gui.destination_viewer.displayedlist_ids.index(x.obj.id) # Get index of DESTSQUARE from GRIDSQUARE in DESTGRID
                            destsquare = gui.destination_viewer.displayedlist[a]
                            remove.append(destsquare) # REMOVE SQUARE
                        else: # GRIDSQUARE NOT IN DESTGRID
                            pass # DO NOTHING!

                    elif gui.destination_viewer.dest_path == x.obj.dest: # GRIDSQUARE is DESTINED to DESTGRID
                        if x.obj.id in gui.destination_viewer.displayedlist_ids: # GRIDSQUARE ALREADY IN DESTGRID
                            a = gui.destination_viewer.displayedlist_ids.index(x.obj.id) # Get index of DESTSQUARE from GRIDSQUARE in DESTGRID
                            destsquare = gui.destination_viewer.displayedlist[a]
                            add.append((destsquare, "refresh")) # REFRESH SQUARE.
                        else: #GRIDSQUARE NOT IN DETGRID
                            add.append((x.obj, "add")) # ADD SQUARE

                # Move from list to list
                if gui.current_view.get() == "Show Unassigned":
                    if x in gridmanager.displayedset:
                        gridmanager.unassigned.remove(x)
                        gridmanager.assigned.append(x)
                        to_remove_from_grid.append(x)

                # Moving from assigned to assigned
                elif gui.current_view.get() == "Show Assigned":
                    if x in gridmanager.displayedset:
                        gridmanager.assigned.remove(x)
                        gridmanager.assigned.append(x)
                        to_refresh_from_grid.append(x) # Means we want to update pos so it lines up with assigned list order.
                        #dest, dest may be changed, check if destsquare is same as gridsquare, if not, nothing, if yes, remove.

                # Moving from moved to assigned
                elif gui.current_view.get() == "Show Moved":
                    if x in gridmanager.displayedset:
                        gridmanager.moved.remove(x)
                        gridmanager.assigned.append(x)
                        to_remove_from_grid.append(x)
                
                elif gui.current_view.get() == "Show Animated":
                    if x in gridmanager.displayedset:
                        gridmanager.assigned.append(x)
                        to_remove_from_grid.append(x)
            "Add and remove from imagegrid"

            gridmanager.remove_squares(to_remove_from_grid, unload=True) # Moved/unassigned/animated scenarios
            
            "Assigned view: remove and add square back so it is 'newest'" # Wont run if above runs, because method is passed an empty list then.
            gridmanager.remove_squares(to_refresh_from_grid, unload=False) # Assigned scenario
            gridmanager.add_squares(to_refresh_from_grid)

            "Add and remove from destgrid" #if assigned above
            if remove:
                gui.destination_viewer.remove_squares(remove, unload=True)
            if add:
                gui.destination_viewer.add_squares(add)
            "If show next option checked, and next exists, and viewer is open, show next image"
            if self.navigator.old and len(gridmanager.displayedset) >= 1:
                self.navigator.select_next(gridmanager.displayedlist)

            if gui.auto_load and gui.current_view.get() == "Show Unassigned": 
                if gui.squares_per_page_intvar.get() > len(gridmanager.displayedlist):
                    to_load = gui.squares_per_page_intvar.get() - len(gridmanager.displayedlist)
                    left = len(self.imagelist)
                    items = min(to_load, left)
                    gridmanager.load_more(amount=items) # the unload thread might access stuff simultneous to this one.
            "Update stat tracker"
            self.gui.images_left_stats_strvar.set(
                f"Left: {len(gridmanager.assigned)}/{len(gridmanager.gridsquarelist)-len(gridmanager.assigned)-len(gridmanager.moved)}/{len(self.imagelist)}")
                

    def setup(self, dest): # scan the destination
        def randomColor():
            r = int(random() * 256)  # Range: 0 to 255
            g = int(random() * 256)  # Range: 0 to 255
            b = int(random() * 256)  # Range: 0 to 255

            # Ensure the color is not too light by checking the brightness
            brightness = (r * 0.299 + g * 0.587 + b * 0.114)
            if brightness > 200:  # Adjust this threshold as needed
                # If too light, adjust one of the colors down
                if r > g and r > b:
                    r = max(0, r - 50)
                elif g > r and g > b:
                    g = max(0, g - 50)
                else:
                    b = max(0, b - 50)

            return f'#{r:02X}{g:02X}{b:02X}'
        self.destinations = []
        self.destinationsraw = []
        with os.scandir(dest) as it:
            for entry in it:
                if entry.is_dir():
                    seed(entry.name)
                    self.destinations.append(
                        {'name': entry.name, 'path': entry.path, 'color': randomColor()})
                    self.destinationsraw.append(entry.path)
    def validate(self):
        gui = self.gui
        gridmanager = gui
        self.timer.start()
        self.sdp = gui.source_entry_field.get()
        self.ddp = gui.destination_entry_field.get()
        samepath = (self.sdp == self.ddp)

        if ((os.path.isdir(self.sdp)) and (os.path.isdir(self.ddp)) and not samepath):
            self.setup(self.ddp)
            gui.guisetup(self.destinations)
            gui.initial_dock_setup()

            gui.destination_viewer.get_paths()
            gui.sessionpathvar.set(os.path.basename(
                self.sdp)+"-"+os.path.basename(self.ddp)+".json")

            print("")
            print(f'New session:  "{gui.sessionpathvar.get()}"')
            print(f'Source:   "{self.sdp}"')
            print(f'Target:   "{self.ddp}"')
            
            self.walk(self.sdp)
            gui.manage_lines(f"Files searched in: {self.timer.stop()}", clear=True)
            self.timer.start()

            gui.gridmanager.load_more()

        elif samepath:
            gui.source_entry_field.delete(0, tk.END)
            gui.destination_entry_field.delete(0, tk.END)
            gui.source_entry_field.insert(0, "PATHS CANNOT BE SAME")
            gui.destination_entry_field.insert(0, "PATHS CANNOT BE SAME")
        else:
            gui.source_entry_field.delete(0, tk.END)
            gui.destination_entry_field.delete(0, tk.END)
            gui.source_entry_field.insert(0, "ERROR INVALID PATH")
            gui.destination_entry_field.insert(0, "ERROR INVALID PATH")

    def walk(self, src):
        supported_formats = {"png", "gif", "jpg", "jpeg", "bmp", "pcx", "tiff", "webp", "psd", "jfif", "mp4", "webm"}
        animation_support = {"gif", "webp", "mp4", "webm"} # For clarity

        for root, dirs, files in os.walk(src, topdown=True):
            dirs[:] = [d for d in dirs if d not in self.exclude]

            for name in files:
                parts = name.rsplit(".", 1)
                if len(parts) == 2:
                    n, ext = parts
                    ext = ext.lower()
                else:
                    n = parts[0]
                    ext = ""
                
                if ext in supported_formats:
                    imgfile = Imagefile(name, os.path.join(root, name), ext) # 24.5
                    self.imagelist.append(imgfile)

        # Sort by date modificated
        if self.gui.sort_by_date_boolvar.get():
            self.imagelist.sort(key=lambda img: os.path.getmtime(img.path), reverse=False) # 65

        return self.imagelist
    def clear(self, *args):
        if askokcancel("Confirm", "Really clear your selection?"):
            for x in self.imagelist:
                x.checked.set(False)

class ThumbManager:
    "Thumbmanager class to manage memory usage of images in grid."
    def __init__(self, fileManager):
        self.animate = fileManager.animate
        self.mem = {}
        self.threads = fileManager.threads
        self.data_dir = fileManager.data_dir
        self.gui = fileManager.gui
        self.fileManager = fileManager

        self.gen_thread = None
        self.new_thread = None

        self.supported_formats = {"png", "jpg", "jpeg", "bmp", "pcx", "tiff", "psd", "jfif", "gif", "webp"}
        self.animated_thumb_formats = {"gif", "webp", "webm"}
        self.video_formats = {"webm", "mp4"}
    
    def truncate_text(self, imageobj): #may fail for very small thumbsizes # very inefficient ###
        filename = imageobj.name
        parts = filename.rsplit(".", 1)
        if len(parts) == 2:
            base_name, ext = parts
            ext = ext
        else:
            base_name = parts[0]
            ext = ""
        smallfont = self.gui.smallfont
        text_width = smallfont.measure(filename)
        if text_width+24 <= self.gui.thumbnailsize:
            return filename # Return whole filename
        ext = "...." + ext
        while True: # Return filename that has been truncated.
            test_text = base_name + ext # Test with one less character
            text_width = smallfont.measure(test_text)
            if text_width+24 < self.gui.thumbnailsize:  # Reserve space for ellipsis
                break
            base_name = base_name[:-2]
        return test_text

    def generate(self, gridsquares, dest=False, queue=False):
        mem = self.mem
        gui = self.gui
        def queue_trail():
            
            fileManager = self.fileManager
            animation_queue = fileManager.animation_queue
            temp = reversed(animation_queue)
            for x in temp:
                if x.guidata.get("frame", None) or x.guidata.get("destframe", None):
                    gen_frames(x)
                else:
                    animation_queue.remove(x)
        def gen_thumb(imagefile): # session just calls this for displayedlist
            def get_mode(vips_img):
                pformat = str(vips_img.interpretation).lower()
                
                "Debug code"
                if pformat in mem:
                    mem[pformat] = mem[pformat]+1
                else:
                    mem[pformat] = 1

                "Most common formats are srgb, b-w, rgb16 and grey16. We get the pillows equivalent 'mode' for frombytes method"
                if pformat == "srgb":
                    if vips_img.bands == 3: mode = "RGB"
                    elif vips_img.bands == 4: 
                        mode = "RGBA" # Transparency. Able to view photos with invisible background.
                elif pformat == "b-w":
                    mode = "L"
                elif pformat == "rgb16":
                    mode = "I;16"
                elif pformat == "grey16":
                    mode = "I;16"
                else:
                    print("Our pyvips interpreter encountered an unsupported format (not srgb, b-w, rgb16 or grey16):", vips_img.interpretation, imagefile.name)
                return mode

            def load_thumb(im, load=False):
                #copy over if img exists
                if load and dest:
                    frame = imagefile.guidata['destframe']
                    frame.canvas.image = im
                    frame.canvas.itemconfig(frame.canvas_image_id, image=im)
                    return
                elif load:
                    canvas = imagefile.guidata['canvas']
                    frame = imagefile.guidata['frame']
                    canvas.image = im
                    canvas.itemconfig(frame.canvas_image_id, image=im)
                    return
                if dest:
                    frame = imagefile.guidata['destframe']
                    frame.canvas.image = im
                    frame.canvas.itemconfig(frame.canvas_image_id, image=im)
                    return


                imagefile.guidata['img'] = im
                canvas = imagefile.guidata['canvas']
                frame = imagefile.guidata['frame']
                canvas.image = im
                canvas.itemconfig(frame.canvas_image_id, image=im)
            
            temp = imagefile.guidata.get("img", None)
            if temp:
                load_thumb(temp, load=True)
                return
            if not imagefile.id:
                #Hash using name, size, mod time. Creates unique thumb name.
                file_name1 = imagefile.path.replace('\\', '/').split('/')[-1]
                if not imagefile.file_size or not imagefile.mod_time:
                    file_stats = os.stat(imagefile.path)
                    imagefile.file_size = file_stats.st_size
                    imagefile.mod_time = file_stats.st_mtime
                id = file_name1 + " " +str(imagefile.file_size)+ " " + str(imagefile.mod_time)
                hash = md5()
                hash.update(id.encode('utf-8'))
                imagefile.id = hash.hexdigest()

            thumbpath = os.path.join(self.data_dir, imagefile.id+os.extsep+"webp") # if you change format, you must reconfigure validate_thumbnail_cache to that prefix.
            
            "Thumbnail found and obj is saved the reference"
            if (os.path.exists(thumbpath)):
                imagefile.thumbnail = thumbpath
                try:
                    pyvips_image = pyvips.Image.new_from_file(imagefile.thumbnail)
                    mode = get_mode(pyvips_image)

                    buffer = pyvips_image.write_to_memory()
                    pillows_image = Image.frombytes(
                        mode, (pyvips_image.width, pyvips_image.height), buffer, "raw")
                    buffer = None
                    pyvips_image = None

                    imagetk = ImageTk.PhotoImage(pillows_image) # hangs here
                    if imagefile.ext in self.video_formats:
                        imagefile.dimensions = (imagetk.width(), imagetk.height())

                    load_thumb(imagetk)       
                except Exception as e:
                    print(f"Pyvips couldn't load thumbnail from data: {imagefile.name} : Error: {e}. Trying with pillows.")
                    try:
                        with Image.open(imagefile.thumbnail) as image:
                            imagetk = ImageTk.PhotoImage(image)
                            load_thumb(imagetk)
                    except Exception as e:
                        print(f"Pillows couldn't load thumbnail from data: {imagefile.name} : Error: {e}.")

                "Generate thumbnails and save to data folder." "PNG, JPG, GIF, WEBP"
            else:
                if imagefile.ext in self.video_formats: #mp4, webm
                    try:
                        reader = None
                        reader = get_reader(imagefile.path)
                        pillows_image = Image.fromarray(reader.get_data(0))
                        pillows_image.thumbnail((gui.thumbnailsize,gui.thumbnailsize))

                        imagetk = ImageTk.PhotoImage(pillows_image)
                        imagefile.dimensions = (imagetk.width(), imagetk.height())

                        if pillows_image.mode != "RGB": # Convert to a standard RGB for robustness
                            pillows_image = pillows_image.convert("RGB")

                        pillows_image.save(thumbpath)
                        imagefile.thumbnail = thumbpath

                        load_thumb(imagetk)
                    except Exception as e:
                        print(f"Couldn't create thumbnail for video: {imagefile.name} : Error: {e}")
                    finally:
                        if reader:
                            reader.close()
                        return
                #Else
                try: # Pyvips method is faster than pillows
                    #raise Exception("")
                    "Pyvips, load image and make a thumbnail and get interpreatation for pillows frombytes"
                    #vips_image = pyvips.Image.new_from_file(imagefile.path, access="sequential") # use this to find strange formats. thumbnail seems to convert them.
                    vips_image = pyvips.Image.thumbnail(imagefile.path, gui.thumbnailsize) # get_mode is kind of useless now. should recognize diff between rgb and rgba though, but not the other types.
                    mode = get_mode(vips_image)

                    buffer = vips_image.write_to_memory() # Pyvips, write thumbnail image to a memory array
                    "Pillows, Read the array and create a pillows image. This needs a 'mode' and will fail if incorrect."
                    pillows_image = Image.frombytes(
                            mode, (vips_image.width, vips_image.height), buffer, "raw")
                    #pillows_image = Image.frombuffer(
                     #       mode, (vips_image.width, vips_image.height), buffer, "raw")
                    vips_image = None
                    buffer = None
                    
                    if mode == "RGBA":
                        pillows_image.save(thumbpath, format="webp")
                    else:
                        if pillows_image.mode != "RGB": # Convert to a standard RGB for robustness
                            pillows_image = pillows_image.convert("RGB")
                        pillows_image.save(thumbpath, format="webp")

                    #pillows_image.save(thumbpath)
                    imagefile.thumbnail = thumbpath

                    imagetk_image = ImageTk.PhotoImage(pillows_image)
                    load_thumb(imagetk_image)

                except Exception as e: # Pillow fallback
                    print(f"Pyvips couldn't create thumbnail: {imagefile.name} : Error: {e}. Trying with pillows.")
                    try:
                        with Image.open(imagefile.path) as pillows_image:

                            pillows_image.thumbnail((gui.thumbnailsize,gui.thumbnailsize))

                            if pillows_image.mode != "RGB": # Convert to a standard RGB for robustness
                                pillows_image = pillows_image.convert("RGB")

                            pillows_image.save(thumbpath)
                            imagefile.thumbnail = thumbpath

                            imagetk = ImageTk.PhotoImage(pillows_image)
                            load_thumb(imagetk)

                    except Exception as e:
                        print(f"Pillows couldn't create thumbnail: {imagefile.name} : Error: {e}")

        def gen_name(imagefile):
        
            #---------
            imagefile.truncated_filename = self.truncate_text(imagefile)
            if imagefile.guidata.get("frame", None) != None:
                frame = imagefile.guidata['frame'] # Gen it once to imagefile. Check if frame and dest exists, load it in those gridsquares, if trunc not set.
                frame.obj2.set(imagefile.truncated_filename)
            if imagefile.guidata.get("destframe", None) != None:
                destframe = imagefile.guidata['destframe']
                destframe.obj2.set(imagefile.truncated_filename)
        def gen_frames(imagefile): # session just calls this for displayedlist -> called only after gen_anim_data for all. Now this has framecounts.
            if imagefile.frames:
                #print("frames already exist")
                return
            
            while not self.fileManager.program_is_exiting and self.fileManager.gui.concurrent_frames < self.fileManager.max_concurrent_frames:
                # Clear frames just in case.
                if not isinstance(imagefile.frames, list):
                    imagefile.frames = []
                if not isinstance(imagefile.frametimes, list):
                    imagefile.frametimes = []
                if imagefile.ext in self.video_formats: #webm
                    try:
                        imagefile.frametimes.clear()
                        imagefile.index = 0
                        imagefile.frames.clear()
                        imagefile.framecount = 0
                        reader = get_reader(imagefile.path)
                        fps = (reader.get_meta_data().get('fps', 24))
                        imagefile.delay = int(round((1 / fps)*1000))
                        if round(imagefile.file_size/1.048576/1000000,2) > 10:
                            #print(f"{imagefile.name} is too big for grid animation.")
                            imagefile.framecount = 2 # to register as "animated"
                            if imagefile in self.fileManager.animation_queue:
                                self.fileManager.animation_queue.remove(imagefile)
                            return
                        f = True
                        for frame in reader:
                            if not self.fileManager.gui.concurrent_frames < self.fileManager.max_concurrent_frames:
                                imagefile.frametimes.clear()
                                imagefile.frames.clear()
                                imagefile.index = 0
                                imagefile.framecount = 0
                                if imagefile not in self.fileManager.animation_queue:
                                    frame = imagefile.guidata.get("frame", None)
                                    destframe = imagefile.guidata.get("destframe", None)
                                    im = imagefile.guidata.get("img", None)
                                    if frame:
                                        if im:
                                            frame.canvas.image = im
                                            frame.canvas.itemconfig(frame.canvas_image_id, image=im)
                                    if destframe:
                                        if im:
                                            destframe.canvas.image = im
                                            destframe.canvas.itemconfig(destframe.canvas_image_id, image=im)
                                return
                        
                            if self.fileManager.program_is_exiting:
                                return
                            image = Image.fromarray(frame)
                            image.thumbnail((gui.thumbnailsize,gui.thumbnailsize))
                            tk_image = ImageTk.PhotoImage(image)
                            imagefile.frames.append(tk_image)
                            imagefile.framecount += 1
                            imagefile.frametimes.append(imagefile.delay)
                            if f:
                                self.animate.add_animation(imagefile)
                                f = False
                        self.fileManager.animation_queue.append(imagefile)
                        imagefile.lazy_loading = False
                        if imagefile in self.fileManager.animation_queue:
                            self.fileManager.animation_queue.remove(imagefile)
                    except Exception as e:
                        print(f"Error in frame generation for grid: {e}")
                    finally:
                        if reader:
                            reader.close()
                        return
                else: # Load frames for GIF, WEBP
                    try:
                        try:
                            frames = mimread(imagefile.path)
                        except Exception as e:
                            if imagefile in self.fileManager.animation_queue:
                                self.fileManager.animation_queue.remove(imagefile)
                            return
                        temp = []
                        for x in frames:
                            if not self.fileManager.gui.concurrent_frames < self.fileManager.max_concurrent_frames:
                                imagefile.frametimes.clear()
                                imagefile.index = 0
                                imagefile.frames.clear()
                                imagefile.framecount = 0
                                if imagefile not in self.fileManager.animation_queue:
                                    
                                    frame = imagefile.guidata.get("frame", None)
                                    destframe = imagefile.guidata.get("destframe", None)
                                    im = imagefile.guidata.get("img", None)
                                    if frame:
                                        if im:
                                            frame.canvas.image = im
                                            frame.canvas.itemconfig(frame.canvas_image_id, image=im)
                                    if destframe:
                                        if im:
                                            destframe.canvas.image = im
                                            destframe.canvas.itemconfig(destframe.canvas_image_id, image=im)
                                return
                            if self.fileManager.program_is_exiting:
                                return
                            frame_rgb = np.array(x)
                            frame_pil = Image.fromarray(frame_rgb)
                            frame_pil.thumbnail((256,256), Image.Resampling.LANCZOS)
                            frame_tk = ImageTk.PhotoImage(frame_pil)
                            temp.append(frame_tk)
                        self.fileManager.animation_queue.append(imagefile)
                        if len(temp) == 1:
                            if imagefile in self.fileManager.animation_queue:
                                self.fileManager.animation_queue.remove(imagefile)
                                return
                        if not len(temp) == len(imagefile.frames):
                            imagefile.frames = temp # If you clear the original list, the old list pointers will dissappear for a while and the loop will be interrupted.
                            imagefile.frametimes = [frame.meta['duration'] for frame in get_reader(imagefile.path)]
                            imagefile.framecount = len(imagefile.frames)
                        imagefile.lazy_loading = False
                        if len(imagefile.frames) > 1:
                            if imagefile in self.fileManager.animation_queue:
                                self.fileManager.animation_queue.remove(imagefile)
                            self.animate.add_animation(imagefile)
                        return
                    except Exception as e:
                        print(e)
                break
            imagefile.frametimes.clear()
            imagefile.index = 0
            imagefile.frames.clear()
            imagefile.framecount = 0
            if imagefile not in self.fileManager.animation_queue:
                self.fileManager.animation_queue.append(imagefile)
                frame = imagefile.guidata.get("frame", None)
                destframe = imagefile.guidata.get("destframe", None)
                im = imagefile.guidata.get("img", None)
                if frame:
                    if im:
                        frame.canvas.image = im
                        frame.canvas.itemconfig(frame.canvas_image_id, image=im)
                if destframe:
                    if im:
                        destframe.canvas.image = im
                        destframe.canvas.itemconfig(destframe.canvas_image_id, image=im)


        def multithread():
            if self.gen_thread != None:
                self.gen_thread.join()
            self.fileManager.program_is_exiting = False
            self.gen_thread = self.new_thread
            # when gen called from dest, know it. check if img exists, set it. if doesnt continue loading img to guidata.
            static = [x for x in objects]
            gen_truncated_names = [x for x in objects if x.truncated_filename == "..."]
            animated = [x for x in objects if x.ext in self.animated_thumb_formats]
            while not self.fileManager.program_is_exiting:
                try:
                    if not queue:
                        max_workers = max(1,self.threads*2)

                        with ThreadPoolExecutor(max_workers=max_workers) as executor: # NAMES
                            executor.map(gen_name, gen_truncated_names)

                        gui.manage_lines(f"Names shortened in: {self.fileManager.timer.stop()}", clear=True)
                        self.fileManager.timer.start()

                        with ThreadPoolExecutor(max_workers=max_workers) as executor: # THUMBS
                            executor.map(gen_thumb, static)

                        gui.manage_lines(f"Thumbnails generated in: {self.fileManager.timer.stop()}")
                        #gui.manage_lines(f"Private Line: {mem}")
                        self.fileManager.timer.start()
        
                        

                        max_workers = max(1,self.threads)
                        with ThreadPoolExecutor(max_workers=max_workers) as executor: # FRAMES
                            executor.map(gen_frames, animated)

                        gui.manage_lines(f"Thumbframes generated in: {self.fileManager.timer.stop()}")
                        self.fileManager.timer.start()
                    else:
                        queue_trail()

                except Exception as e:
                    print("Error in generating thumbs and frames", e)
                break
            return

        if gridsquares and isinstance(gridsquares[0], tk.Frame): # Can pass gridsquares or objects. More control.
            objects = [x.obj for x in gridsquares]
        else:
            objects = gridsquares
        if self.gen_thread == None or self.gen_thread.is_alive(): 
            self.fileManager.program_is_exiting = True
        self.new_thread = Thread(target=multithread, daemon=True)
        self.new_thread.start()

    def unload(self, gridsquares, dest=False): # thread? ### need thread because unload is very slow for 1000 pics.
        gui = self.gui
        def multithread3():
            try:
                max_workers = max(1,self.threads*2)
                with ThreadPoolExecutor(max_workers=max_workers, thread_name_prefix = "unload-anim") as executor:
                   
                   executor.map(unload_animated, gridsquares)
                max_workers = max(1,self.threads*2)
                with ThreadPoolExecutor(max_workers=max_workers, thread_name_prefix = "unload-static") as executor:
                   executor.map(unload_static, gridsquares)    
                if self.fileManager.animation_queue:
                    self.generate(self.fileManager.animation_queue, queue=True)
            except Exception as e:
                print("Error unloading thumbs and frames", e)
            finally:
                collect()

        def unload_static(gridsquare):
            if dest == False:
                canvas = gridsquare.obj.guidata.get("canvas", None)
                if canvas:
                    try:
                        if hasattr(gridsquare, "canvas") and hasattr(gridsquare, "canvas_image_id"):
                            gridsquare.canvas.itemconfig(gridsquare.canvas_image_id, image=None)
                            gridsquare.canvas.image = None
                    except Exception as e:
                        print(e)
            frame = gridsquare.obj.guidata.get("frame", None) # remove frame  from guidata.
            destframe = gridsquare.obj.guidata.get("destframe", None)
            
            if not frame and not destframe:
                gridsquare.obj.guidata['img'] = None

        def unload_animated(gridsquare):
            if gridsquare.type == "GRID":
                gridsquare.obj.guidata["frame"] = None
            elif gridsquare.type == "DEST":
                gridsquare.obj.guidata["destframe"] = None
            
            frame = gridsquare.obj.guidata.get("frame", None) # remove frame  from guidata.
            destframe = gridsquare.obj.guidata.get("destframe", None)

            if gridsquare.obj.frames and not frame and not destframe:
                gridsquare.obj.index = 0
                gridsquare.obj.frames = []
                gridsquare.obj.lazy_loading = True
                
        
        self.fileManager.timer.start()
        if gridsquares:
            new_thread = Thread(target=multithread3, daemon=True)
            new_thread.start()

class Animate:
    def __init__(self, fileManager, square_colour):
        self.fileManager = fileManager
        self.gui = fileManager.gui
        self.running = set() # Stores every frame going to be animated or animating.
        self.square_colour = square_colour
        #self.running should hold an obj. if its guidata has "frame" or "destframe", it animates those dynamically if it finds them with the same frames and index
        #important is that self.running shouldnt contain two same objects. 
        # 1. Make it hold objs. # only one obj can be in loop at once, else index goes brr. This is why the running set is here. #
        # 2. Make the animate method check if dest or grid version exists, apply current frame to both. #
        # 3. Have something removing the version from guidata if it is unloaded. Should happen as we unanimate / as we unload the image in general.

    def add_animation(self, obj):
        if obj in self.running:
            return
        self.running.add(obj)
        self.start_animations(obj)
    def remove_animation(self, obj): # make remove of guidata in unload or remove square, then, loop will exit itself.
        # or make another list just for the other dest. probably simpelr. tell start animation what self running it tracks from. remove anim same.
        if obj in self.running:
            self.running.remove(obj)
    def start_animations(self, obj):
        def lazy(obj): # d0 th9s
            if self.gui.do_anim_loading_colors:
                if obj.guidata.get("canvas", None):
                    obj.guidata["canvas"]['background'] = "red" # note this points to gridsquare canvas.
            if obj not in self.running: # Stop if not in "view" or in self.running
                return
            if not obj.frames: # No frames have been initialized. Or were removed.
                self.remove_animation(obj)
                return
            if not obj.lazy_loading and len(obj.frames) != obj.framecount: # All frames generated doesnt match expected (only webm, dead?)
                print("Error, frames generated doesnt match expected")
                self.remove_animation(obj)
                return
            if not obj.lazy_loading and len(obj.frames) == obj.framecount: # All frames ready. (second part only webm, dead)
                if self.gui.do_anim_loading_colors:
                    if obj.guidata.get("canvas", None):
                        obj.guidata["canvas"]['background'] = "green"
                loop(obj)
            else:
                animate_these = []
                frame = obj.guidata.get("frame", None)
                destframe = obj.guidata.get("destframe", None)

                if frame: animate_these.append(frame)
                if destframe: animate_these.append(destframe)

                if not animate_these:
                    self.remove_animation(obj)
                    return

                for i in animate_these:    
                    try:
                        if len(obj.frames) > obj.index: # When next frame is available, but not all of them exist yet.
                            i.canvas.itemconfig(i.canvas_image_id, image=obj.frames[obj.index])
                            obj.index = (obj.index + 1) % obj.framecount
                            i.canvas.after(obj.frametimes[obj.index], lambda: lazy(obj))
                        else: # Frame must wait to ge generated, wait.
                            i.canvas.after(obj.delay, lambda: lazy(obj))  #default delay instead 100 ms.
                    except Exception as e:
                        self.remove_animation(obj)
                        print("Error in lazy:", e)
        def loop(obj):
            "Indefinite loop on a seperate thread until it just ends"
            animate_these = []
            frame = obj.guidata.get("frame", None)
            destframe = obj.guidata.get("destframe", None) 
            # could just do "shown in dest show in grid flags" much simpler. guidata is just a dict attribute anyway.
            if not frame and not destframe:
                self.remove_animation(obj)
                return
            if not obj.frames:
                self.remove_animation(obj)
                return

            if frame: animate_these.append(frame) # but how would I retrieve the dests? # maybe attribute in_grids = {} could iterate over that simply.
            if destframe: animate_these.append(destframe)

            if not animate_these:
                self.remove_animation(obj)
                return
            
            for i in animate_these:
                try:
                    if len(obj.frames) >= obj.index:
                        i.canvas.itemconfig(i.canvas_image_id, image=obj.frames[obj.index]) #change the frame
                except:
                    pass
            obj.index = (obj.index + 1) % obj.framecount
            self.fileManager.gui.after(obj.frametimes[obj.index], lambda: loop(obj)) #run again.

        lazy(obj) # Non threaded

class Timer:
    "Timer for benchmarking"
    def __init__(self):
        self.creation_time = None
    def start(self):
        self.creation_time = perf_counter()
    def stop(self):
        current_time = perf_counter()
        elapsed_time = current_time - self.creation_time
        return f"{elapsed_time:.3f} s"

if __name__ == '__main__':
    mainclass = SortImages()
