#pip freeze > requirements.txt && pip uninstall -r requirements.txt -y && del requirements.txt
from time import perf_counter

import os
import json

from shutil import rmtree, move as shutilmove
from random import seed, random

from threading import Thread, Event
import tkinter as tk

from gui import GUIManager
from navigator import Navigator
from PIL import Image, ImageTk

import ctypes
ctypes.windll.shcore.SetProcessDpiAwareness(1)
# canvasimage
    # double click for gifs not working in canvasimage.
    # test the other application too.
# destview
    # destview not supported
# application
    # displayedset wont keep ORDER for list... the fuck?
    # color creation stalls the whole program...?
    # throttling for displayimage? Replace the current system with a simple keypress, release system. unlimited for single keypresses, throttled for long presses.
    # long presses dont display images. long press starts by going down 1. thne counting to some integer, then starting scrolling downwards without loading images.

# lists
    # some errors when assigning from assigned view. also no assigned color in assigned view
    # should dissappear from animated view if assigned.
    # dont brng them to animated if assigned...
#testing
    # make sure name conflicts dont overwrite. maybe just put into assign, cant move, so it stays in assign.




def import_pyvips():
    "This looks scary, but it just points to where 'import pyvips' can find it's files from"
    "To update this module, change vips-dev-8.16 to your new folder name here and in build.bat"
    base_path = os.path.dirname(os.path.abspath(__file__))
    vipsbin = os.path.join(base_path, "vips-dev-8.16", "bin")
    
    if not os.path.exists(vipsbin):
        raise FileNotFoundError(f"The directory {vipsbin} does not exist.")

    os.environ['PATH'] = os.pathsep.join((vipsbin, os.environ['PATH']))
    os.add_dll_directory(vipsbin)
import_pyvips()
try:
    import pyvips
except Exception as e:
    print("Couldn't import pyvips:", e)

"Memory"
# Fail to allocate bitmap memory issue. Tkinter or PIL cant juggle a lot of animated images at the same time. Load less of them.
# Use self.max_concurrent_frames = 5000 to set memory limit and lower self.threads if you lag.
# redo rename
class Imagefile:
    ANIMATION = "ANIMATION"
    IMAGE = "IMAGE"
    VIDEO = "VIDEO"

    def __init__(self, name, path, ext) -> None:
        "An Imagefile object stores data about the image to help us manage it in the program"
        "Normal attributes"        
        self.name = name
        self.truncated_filename = "..."
        self.path = path
        self.dest = ""
        self.thumbnail = None           # Path to the cached thumbnail in data directory
        self.moved = False              # Used to track if img is sorted
        self.ext = ext
        self.color = None # dest color

        "Hash"
        self.id = None              # Hash of img name, mod_time and file_size. This is faster to hash than whole file binary stream.
        self.mod_time = None        # Used by sortimages. Used to hash id.
        self.file_size = None       # Used by canvasimage. Buffers if large enough. Used to hash id.

        "Animation"
        self.lazy_loading = True    # The animate-class checks for this flag to switch from lazy loading to the permanent loop.
        self.frames = []            # PIL frames for animation with tkinter for imagegrid. Generated by ThumbManager (self.animate) for gif, webp and webm.
        self.frametimes = []        # Used for animating at correct speed. Generated by thumbmanager.generate.
        self.type = None            # Are we an animation or an image, uses self.ANIMATION and self.IMAGE.
        self.index = 0              # Used to control what frame is displayed (for imgagegrid).
        self.delay = 100            #Default delay. Used to fill frametimes if speed can't be extracted from file.
        self.thumb = None           # Store the thumbnail imagetk
        self.frame = None           # Reference to gridframe
        self.destframe = None       # Reference to destframe

    def setdest(self, dest) -> None:
        "Sets imagefile dest and destcolor to desired."
        self.dest = dest["path"]
        self.color = dest["color"]
        print("Set destination of  self.name to self.dest")

    def rename(self, name, fileManager):
        new_path = f"{self.path[:-len(self.name)]}{name}"
        os.rename(self.path, new_path)
        self.path = new_path
        self.name = name
        """self.truncated_filename = fileManager.thumbs.truncate_text(self)
        self.frame.obj2.set(self.truncated_filename)
        fileManager.gui.displayimage(fileManager.navigator.select(fileManager.navigator.old))"""

    def move(self):
        "Move image from self.path to self.dest and set self.dest = ''. Turn moved flag to True"

        if not self.dest or not os.path.isdir(self.dest): return

        "Pointers"
        name = self.name # in function, better to point  like this or call each time? ###
        old_path = self.path + "" # Perhaps unnecessary, if shutil fails, self.path wont get set to destpath. This is for clarity. This is original path of the file.
        destpath = os.path.join(self.dest, name)

        "Check for conflicts: file with same name already in dest." "Refuse to overwrite anything"
        if os.path.exists(destpath): # path/to/dest/filename
            print(f"File {name[:30]} already exists in destination. No action") # would overwrite with same name otherwise.
            if self.path == destpath: 
                return True # already exists there.
            return False

        try:
            shutilmove(self.path, destpath) # Copy -> Delete. If either fail, do exceptions.
            self.path = destpath
            self.dest = ""
            self.moved = True
            return True
        except Exception as e:
            "Shutil failed: Did delete old fail?"
            if os.path.exists(destpath) and os.path.exists(old_path): # This can only remove files created by shutil due to our early exits checking for anything in the way. Safe.
                os.remove(destpath)
                print(f"File {name[:30]} is in use and is unable to delete. Removing created copy from destination.")
            else:
                print(f"Error moving/deleting: {e} {name[:30]}, This error shouldn't be raised at all. Report/investigate")
            return False

class SortImages:
    supported_formats = {"png", "gif", "jpg", "jpeg", "bmp", "pcx", "tiff", "webp", "psd", "jfif", "mp4", "webm"}

    script_dir = os.path.dirname(os.path.abspath(__file__))
    data_dir = os.path.join(script_dir, "data")
    prefs_path = os.path.join(script_dir, "prefs.json")
    themes_path = os.path.join(script_dir, "themes.json")

    btn_thumbs = {}

    imagelist = [] # Store all Imagefiles
    destinations = []
    exclude = []

    # Flow
    thread_is_exiting = False
    shut_down = False
    last_call_time = 0
    throttle_delay = 0.19

    # Flags
    autosave = True
    threads = os.cpu_count()//2
    concurrent_frames = 0
    max_concurrent_frames = 4000
    def __init__(self) -> None:
        "Sortimages setups the program. It creates imagefiles from the folder given, loads and saves prefs, loads and saves sessions, and starts up the gui and other modules."
        
        self.jthemes = self.load_themes()

        "Timekeeping and throttling"
        self.timer = Timer()        # Time since creation.

        "Start modules"
        prefs = self.loadprefs()
        self.gui = GUIManager(self, prefs)
        self.gui.initialize()       # Let GUI initialize fully now with loaded values.
        self.navigator = Navigator(self) # Navigator highlights the current selection, main use is to be able to navigate using arrow or wasd keys ### (wasd not implemented)
        self.animate = Animate(self) # Animate module is dedicated for making things animated.
        self.thumbs = ThumbManager(self) # Thumbmanager generates thumbs, frames, truncated names and imagefile attributes, and reloads and unloads resources when needed.
        self.gui.destination_viewer.set_thumbmanager_and_animate() ###
        self.val_thumb_cache(self.data_dir)
        self.btn_thumbs.update({"default": ImageTk.PhotoImage(Image.open(os.path.join(self.script_dir, "button.png"))), "pressed": ImageTk.PhotoImage(Image.open(os.path.join(self.script_dir, "button_pressed.png")))})
        self.gui.mainloop()

    def val_thumb_cache(self, path):
        "Setups cache folder for thumbnails. If folder doesn't exist, it is created. If the first picture in it is not the expected size, the folder is emptied."

        "Data folder doesn't exists: creates it"
        if not (os.path.exists(path) and os.path.isdir(path)):
            os.mkdir(path)
            return
        
        testable = None
        with os.scandir(path) as entries:
            for entry in entries:
                if entry.is_file() and entry.name.endswith(".webp"):
                    testable = entry
        
        if not testable:
            print(f"Data folder is empty")
            return
        

        with Image.open(testable.path) as im:
            width, height = im.width, im.height
        if max(width, height) != self.gui.thumbnailsize:
            try:
                print("Removing data folder, thumbnailsize changed")
                rmtree(path)
                os.mkdir(path)
                print("Re-created data folder.")
            except Exception as e:
                print(f"Couldn't delete/create data folder: {e}")

    def loadprefs(self):
        "Loads prefs.json. Needs self.gui to be created. This edits self.gui attributes."
        try:
            with open(self.prefs_path, "r") as prefsfile:
                jdata = prefsfile.read()
                jprefs = json.loads(jdata)
                return jprefs
        except Exception as e:
            print(f"Error loading prefs.json: {e}")
            return None
        
    def saveprefs(self, gui):
        "Saves all customizable stuff to prefs.json."
        if gui.middlepane_frame.winfo_width() == 1: # Do not try to save invalid value
            pass
        else:
            gui.middlepane_width = gui.middlepane_frame.winfo_width()

        sdp = gui.source_entry_field.get() if os.path.exists(gui.source_entry_field.get()) else ""
        ddp = gui.destination_entry_field.get() if os.path.exists(gui.destination_entry_field.get()) else ""

        temp = gui.squares_per_page_intvar.get()
        if temp == "":
            temp = 1
        save = {
            "paths": {
                "source": sdp,
                "destination": ddp,
                "lastsession": gui.lastsession.get(),
                "exclude": self.exclude,
            },
            "user": {
                "thumbnailsize": gui.thumbnailsize,
                "hotkeys": gui.hotkeys,
                "centering_button": gui.centering_button,
                "force_scrollbar": gui.force_scrollbar,
                "auto_load": gui.auto_load,
                "do_anim_loading_colors": gui.do_anim_loading_colors,
                "do_debug_terminal": gui.do_debug_terminal
            },
            "technical": {
                "quick_preview_filter": gui.filter_mode,
                "quick_preview_size_threshold": gui.quick_preview_size_threshold,
                "threads": self.threads,
                "max_concurrent_frames": self.max_concurrent_frames,
                "autosave_session":self.autosave,
            },
            
            "qui": {
                "squares_per_page": gui.squares_per_page_intvar.get(),
                "sort_by_date": gui.sort_by_date_boolvar.get(),
                "viewer_x_centering": gui.viewer_x_centering,
                "viewer_y_centering": gui.viewer_y_centering,
                "show_next": gui.show_next.get(),
                "dock_view": gui.dock_view.get(),
                "dock_side": gui.dock_side.get(),
                "theme": gui.theme.get(),
                "volume": gui.volume,
            },
            "window_settings": {
                "main_geometry": gui.winfo_geometry(),
                "viewer_geometry": gui.viewer_geometry,
                "destpane_geometry":gui.destpane_geometry,
                "leftpane_width":gui.leftui.winfo_width(),
                "middlepane_width":gui.middlepane_width,
                "images_sorted":gui.images_sorted.get(),
            }
        }
        save["viewer"] = gui.viewer_prefs

        "Save to prefs.json"
        try:
            with open(self.prefs_path, "w+") as json_file:
                json.dump(save, json_file, indent=4)
        except Exception as e:
            print(("Failed to save prefs:", e))

        "Save session"
        try:
            if self.autosave:
                self.savesession(asksavelocation=False, gui=gui)
        except Exception as e:
            print(("Failed to save session:", e))
    
    def savesession(self, asksavelocation, gui):
        "Saves session. Includes some imagefile data and assigned list ids. Sessions do not support thumbnail_cache_validation. So you cannot change thumbnailsize during one."
        "If there is nothing to save"
        if len(self.imagelist) < 1 and len(gui.gridmanager.gridsquarelist) < 1:
            return

        if asksavelocation:
            from tkinter import filedialog as tkFileDialog
            custom_session_name = f"{os.path.basename(self.sdp)}-{os.path.basename(self.ddp)}.json" 
            filet=[("Javascript Object Notation","*.json")]
            savelocation=tkFileDialog.asksaveasfilename(confirmoverwrite=True,defaultextension=filet,filetypes=filet,
                                                        initialdir=os.getcwd(),initialfile=custom_session_name)
        else:
            savelocation = "last_session.json"

        if not savelocation: return

        "Save imagefile attributes"
        def make_list(squares, is_gridsquare=False):
            imagesavedata = []
            for obj in squares:
                name = obj.name
                imagesavedata.append({
                    "name": name,
                    "file_size": obj.file_size,
                    "id": obj.id,
                    "path": obj.path[:-len(name)],
                    })

                if is_gridsquare:
                    if obj.dest != "":
                        imagesavedata[-1]["dest"] = obj.dest
                    if obj.moved == True:
                        imagesavedata[-1]["moved"] = obj.moved

            return imagesavedata

        objs = [x for x in self.imagelist if not x.id or not x.moved or not x.dest]
        imagelist = make_list(objs)

        gridobjs = [x for x in gui.gridmanager.gridsquarelist]
        gridsquarelist = make_list(gridobjs, is_gridsquare=True)

        "We save the order of the assigned list"
        if gui.sort_by_date_boolvar.get(): 
            order = "modification_date"
        else: order = "default"
        
        save = {"dest": self.ddp, "source": self.sdp, "thumbnailsize":gui.thumbnailsize, "sortorder": order,
                "imagelist": imagelist, "gridsquarelist": gridsquarelist}

        with open(os.path.join(self.script_dir, savelocation), "w+") as json_file:
            json.dump(save, json_file, indent=4)    
    
    def loadsession(self):
        gui = self.gui
        gridmanager = gui.gridmanager
        "Loads session"
        sessionpath = gui.lastsession.get()
        print(sessionpath)
        "If there is no last session, early exit"
        if not (os.path.exists(sessionpath) and os.path.isfile(sessionpath)):
            print("No Last Session!")
            return
        
        with open(sessionpath, "r") as json_file:
            sdata = json_file.read()
            savedata = json.loads(sdata)

        gui.thumbnailsize=savedata['thumbnailsize']

        self.sdp = savedata['source']
        self.ddp = savedata['dest']

        self.setup(savedata['dest'])
        gui.guisetup(self.destinations)

        print("")
        print(f'Using session:  "{os.path.basename(sessionpath)}"')
        print(f'Source:   "{self.sdp}"')
        print(f'Target:   "{self.ddp}"')

        "Load imagefiles and imagelists from session.json"
        def make_list(lista, lista_name):
            for line in savedata[lista_name]:
                name = line['name']
                full_path = line['path']+name
                if os.path.exists(full_path):
                    obj = Imagefile(name, full_path, os.path.splitext(name)[1][1:].lower())
                    if line['id']: # If None, (thumb never generated, skip it (processes the imagelist))
                        obj.thumbnail = self.data_dir + "\\" + line['id'] + ".webp"
                    obj.dest=line.get("dest")
                    if obj.dest == None: obj.dest = ""
                    obj.id=line['id']
                    obj.file_size=line['file_size']
                    obj.moved = line.get("moved")
                    if obj.moved == None: obj.moved = False
                    lista.append(obj) # clear of moved and dest.
        gridsquarelist = []
        make_list(self.imagelist, "imagelist")
        make_list(gridsquarelist, "gridsquarelist")
        moved_or_assigned = []
        unassigned = []
        for x in gridsquarelist:
            if x.moved or x.dest:
                moved_or_assigned.append(x)
            else:
                unassigned.append(x)
            
        "Sort order"
        old_order = savedata["sortorder"]
        new_order = self.gui.sort_by_date_boolvar.get()

        if new_order:
            new_order = "modification_date"
        else: 
            new_order = "default"

        if old_order != new_order:
            if new_order == "default":
                from natsort import natsorted
                self.imagelist = natsorted(self.imagelist, key=attrgetter("name"))
                unassigned = natsorted(unassigned, key=attrgetter("name"))
            else:
                from operator import attrgetter
                for obj in self.imagelist:
                    obj.mod_time = os.path.getmtime(obj.path)
                self.imagelist.sort(key=attrgetter("mod_time"), reverse=False)
                unassigned.sort(key=attrgetter("mod_time"), reverse=False)

        gui.gridmanager.load_session(unassigned, moved_or_assigned) 

        self.gui.images_left_stats_strvar.set(
            f"Left: {len(gridmanager.assigned)}/{len(gridmanager.gridsquarelist)-len(gridmanager.assigned)-len(gridmanager.moved)}/{len(self.imagelist)}")
 
        gui.images_sorted_strvar.set(f"Sorted: {gui.images_sorted.get()}")
    
    def load_themes(self):
        try:
            with open(self.themes_path, "r") as themesfile:
                jdata = themesfile.read()
                jthemes = json.loads(jdata)
                return jthemes["themes"]
        except Exception as e:
            print("Error loading themes:", e)
            return None

    def moveall(self):
        self.timer.start()
        gui = self.gui
        gridmanager = gui.gridmanager
        temp = gridmanager.assigned.copy()
        reopen = "none"

        old = None
        if gui.Image_frame != None:
            old = gui.Image_frame.obj
            gui.middlepane_frame.grid_forget()
            gui.Image_frame.close()
            gui.unbind("<Configure>") ###
            gui.Image_frame = None
            reopen = "window" ###
        elif gui.Image_frame1 != None:
            old = gui.Image_frame1.obj
            gui.middlepane_frame.grid_forget()
            gui.Image_frame1.close()
            gui.unbind("<Configure>") ###
            gui.Image_frame1 = None
            reopen = "dock"

        successfull = []
        for x in temp:
            success = x.obj.move()
            if success: # If move was successfull
                gridmanager.assigned.remove(x)
                gridmanager.moved.add(x)
                gui.images_left_stats_strvar.set(
                    f"Left: {len(gridmanager.assigned)}/{len(gridmanager.gridsquarelist)-len(gridmanager.assigned)-len(gridmanager.moved)}/{len(self.imagelist)}")
                gui.images_sorted.set(gui.images_sorted.get()+1)
                gui.images_sorted_strvar.set(f"Sorted: {gui.images_sorted.get()}")
                successfull.append(x)
        gridmanager.remove_squares(successfull, unload=True)

        ###
        """if reopen == "window": gui.displayimage(old)
        elif reopen =="dock": gui.displayimage(old)"""

        print(self.timer.stop())

    def setDestination(self, dest, caller=None):
        "Ignored"
        gui = self.gui
        marked = gui.imagegrid.selected.copy()
        if self.navigator.old and not marked and self.navigator.old.frame != None:
            marked.add(self.navigator.old.frame)

        if not marked: return
        "Ignore calls from certain widgets"
        if caller and isinstance(caller.widget, tk.Entry):
            return
        "Ignore calls if they are spammed"
        current_time = perf_counter()
        if current_time - self.last_call_time < 0.1: return
        else: self.last_call_time = current_time

        
        dest_viewer = gui.destination_viewer
        gridmanager = gui.gridmanager
        navigator = self.navigator

        remove = []
        refresh = []
        
        
        for x in list(marked):
            self.gui.imagegrid.selected.discard(x)
            self.gui.imagegrid.canvas.itemconfig(x.ids["but"], image=self.gui.imagegrid.btn_thumbs["default"])

            obj = x.file
            obj.setdest(dest)
            self.gui.gridmanager.change_square_color(obj, dest['color'], outline=True, fill=False)

            # Move from list to list
            if gui.current_view.get() == "Show Unassigned":
                gridmanager.unassigned.remove(x.file)
                remove.append(x)
            # Moving from assigned to assigned
            elif gui.current_view.get() == "Show Assigned":
                gridmanager.assigned.remove(x.file)
                refresh.append(x)
            # Moving from moved to assigned
            elif gui.current_view.get() == "Show Moved":
                gridmanager.moved.remove(x.file)
                remove.append(x)
            gridmanager.assigned.add(x.file)

        if remove:
            gridmanager.remove_squares(remove, unload=True) # Moved/unassigned/animated scenarios
        elif refresh:
            gridmanager.remove_squares(refresh, unload=False) # Assigned scenario
            gridmanager.add_squares(refresh)

        "Autoload"
        if gui.auto_load and gui.current_view.get() == "Show Unassigned" and gui.squares_per_page_intvar.get() > len(gridmanager.displayedset): 
            to_load = gui.squares_per_page_intvar.get() - len(gridmanager.displayedset)
            left = len(self.imagelist)
            items = min(to_load, left)
            if items > 0: gridmanager.load_more(amount=items)
        
        # Navigator selects the next item under its internal index.
        if navigator.window_focused == "GRID" and navigator.old and len(gridmanager.displayedset) > 0:
            navigator.select_next(gui.imagegrid.image_items)
        # Consider if we focus on destwindow instead, we should use navigate using that list, not default gridlist. This does that
        elif navigator.window_focused == "DEST" and navigator.old and len(dest_viewer.displayedset) > 0:
            navigator.select_next(gui.imagegrid.image_items)
            
        "Update stat tracker"
        gui.images_left_stats_strvar.set(
            f"Left: {len(gridmanager.assigned)}/{len(gridmanager.gridsquarelist)-len(gridmanager.assigned)-len(gridmanager.moved)}/{len(self.imagelist)}")

    def setup(self, dest):
        def randomColor():
            r = int(random() * 256)  # Range: 0 to 255
            g = int(random() * 256)  # Range: 0 to 255
            b = int(random() * 256)  # Range: 0 to 255

            # Ensure the color is not too light by checking the brightness
            brightness = (r * 0.299 + g * 0.587 + b * 0.114)
            if brightness > 200:  # Adjust this threshold as needed
                # If too light, adjust one of the colors down
                if r > g and r > b:
                    r = max(0, r - 50)
                elif g > r and g > b:
                    g = max(0, g - 50)
                else:
                    b = max(0, b - 50)

            return f'#{r:02X}{g:02X}{b:02X}'
        
        self.destinations = []
        self.destinationsraw = []
        with os.scandir(dest) as entries:
            for entry in entries:
                if entry.is_dir():
                    seed(entry.name)
                    self.destinations.append(
                        {'name': entry.name, 'path': entry.path, 'color': randomColor(), 'hotkey': None})
                    self.destinationsraw.append(entry.path)
    
    def validate(self):
        gui = self.gui
        timer = self.timer; timer.start()
        self.sdp = gui.source_entry_field.get()
        self.ddp = gui.destination_entry_field.get()
        samepath = (self.sdp == self.ddp)

        if os.path.isdir(self.sdp) and os.path.isdir(self.ddp):
            self.setup(self.ddp)
            gui.guisetup(self.destinations)
            gui.lastsession.set("last_session.json")
            
            print("")
            print(f'New session:  "{"last_session.json"}"')
            print(f'Source:   "{self.sdp}"')
            print(f'Target:   "{self.ddp}"')
            
            self.walk(self.sdp, samepath)
            gui.manage_lines(f"Files searched in: {timer.stop()}", clear=True)
            timer.start()
            
            gui.gridmanager.load_more()

        else:
            self.sdp.delete(0, tk.END)
            self.ddp.delete(0, tk.END)
            self.sdp.insert(0, "ERROR INVALID PATH")
            self.ddp.insert(0, "ERROR INVALID PATH")
        
        gui.after(3000, self.gui.show_ram_usage)

    def walk(self, src, samepath):
        for root, dirs, files in os.walk(src, topdown=True):
            dirs[:] = [d for d in dirs if d not in self.exclude]
            for name in files:
                parts = name.rsplit(".", 1)
                if len(parts) == 2:
                    n, ext = parts
                    ext = ext.lower()
                else:
                    n = parts[0]
                    ext = ""

                if ext in self.supported_formats:
                    imgfile = Imagefile(name, os.path.join(root, name), ext) # 24.5
                    self.imagelist.append(imgfile)
            
            if samepath:
                break

        from operator import attrgetter
        if self.gui.sort_by_date_boolvar.get():
            for obj in self.imagelist:
                obj.mod_time = os.path.getmtime(obj.path)
            self.imagelist.sort(key=attrgetter("mod_time"), reverse=False) # 65 ######## false
        else:
            from natsort import natsorted
            self.imagelist = natsorted(self.imagelist, key=attrgetter("name"))
        return self.imagelist
    
    def clear(self, *args):
        from tkinter.messagebox import askokcancel
        if askokcancel("Confirm", "Really clear your selection?"):
            self.gui.imagegrid.clear() ###

class CachedTruncator:
    def __init__(self, gui, filemanager):
        self.filemanager = filemanager
        self.gui = gui
        self.prefix_width_cache = {}
        self.char_width_cache = {}
        self.measure_calls = 0
        self.ellipsis = "...."
        self.padding = 24
        self.ellipsis_width = self.gui.smallfont.measure(self.ellipsis)

    def truncate(self, filename):
        parts = filename.rsplit(".", 1)
        
        if len(parts) == 2:
            base, ext = parts
            ext_w = self.prefix_width_cache.get(ext, False)
            if ext_w == False:
                ext_w = self.gui.smallfont.measure(ext)
                self.prefix_width_cache[ext] = ext_w
                self.measure_calls += 1
        else:
            base = filename
            ext = ""
            ext_w = 0

        base_chars_w = []
        base_w = 0
        for char in base:
            char_w = self.char_width_cache.get(char, False)
            if char_w == False:
                char_w = self.gui.smallfont.measure(char)
                self.char_width_cache[char] = char_w
                self.measure_calls += 1

            base_w += char_w
            base_chars_w.append(base_w)
        
        if base_w + ext_w <= self.gui.thumbnailsize - self.padding:
            return filename
        
        available = self.gui.thumbnailsize - self.padding - self.ellipsis_width - ext_w
        
        # Binary search using precomputed widths
        lo, hi = 0, len(base)
        while lo < hi:
            if self.filemanager.thread_is_exiting or self.filemanager.shut_down: return
            mid = (lo + hi + 1) // 2
            if base_chars_w[mid - 1] <= available:
                lo = mid
            else:
                hi = mid - 1

        return f"{base[:lo]}{self.ellipsis}{ext}"

class ThumbManager:
    "Thumbmanager class to manage memory usage of images in grid."
    supported_formats = {"png", "jpg", "jpeg", "bmp", "pcx", "tiff", "psd", "jfif", "gif", "webp"}
    animated_thumb_formats = {"gif", "webp", "webm", "mp4"}
    video_formats = {"webm", "mp4"}

    gen_thread = None
    gen_thread_2 = None

    mem = {}
    block = Event()

    def __init__(self, fileManager):
        self.fileManager = fileManager
        self.animate = fileManager.animate
        self.gui = fileManager.gui

        self.threads = fileManager.threads
        self.data_dir = fileManager.data_dir

        self.truncator = CachedTruncator(self.gui, self.fileManager)

    def gen_name(self, obj):
        if self.fileManager.thread_is_exiting or self.fileManager.shut_down: return
        trunc = self.truncator.truncate(obj.name)
        if obj.frame:
            obj.truncated_filename = trunc
            self.gui.imagegrid.canvas.itemconfig(obj.frame.ids["label"], text=obj.truncated_filename)            
        if obj.destframe:
            obj.destframe.name.set(trunc)
            obj.truncated_filename = trunc

    def gen_thumb(self, obj, dest, gen_name): # session just calls this for displayedlist
        fileManager = self.fileManager
        gui = fileManager.gui
        if self.fileManager.thread_is_exiting or fileManager.shut_down: return
        def get_mode(vips_img):
            pformat = str(vips_img.interpretation).lower()
            
            "Debug code"
            if pformat in self.mem:
                self.mem[pformat] = self.mem[pformat]+1
            else:
                self.mem[pformat] = 1

            "Most common formats are srgb, b-w, rgb16 and grey16. We get the pillows equivalent 'mode' for frombytes method"
            if pformat == "srgb":
                if vips_img.bands == 3: mode = "RGB"
                elif vips_img.bands == 4: 
                    mode = "RGBA" # Transparency. Able to view photos with invisible background.
            elif pformat == "b-w":
                mode = "L"
            elif pformat == "rgb16":
                mode = "I;16"
            elif pformat == "grey16":
                mode = "I;16"
            else:
                print("Our pyvips interpreter encountered an unsupported format (not srgb, b-w, rgb16 or grey16):", vips_img.interpretation, obj.name)
            return mode
        def gen_id(obj):
            from hashlib import md5
            #Hash using name, size, mod time. Creates unique thumb name.
            file_name1 = obj.path.replace('\\', '/').split('/')[-1]
            if not obj.file_size or not obj.mod_time:
                file_stats = os.stat(obj.path)
                obj.file_size = file_stats.st_size
                obj.mod_time = file_stats.st_mtime
            id = file_name1 + " " +str(obj.file_size)+ " " + str(obj.mod_time)
            hash = md5()
            hash.update(id.encode('utf-8'))
            return hash.hexdigest()
        def load_thumb(thumb):
            "Give the img reference to the gridsquare to use. Thread safe."
            def execute_after():
                if gen_name: self.gen_name(obj)
                obj.thumb = thumb
                if obj.frame:
                    self.gui.imagegrid.canvas.itemconfig(obj.frame.ids["img"], image=obj.thumb)     
                if obj.destframe:
                    obj.destframe.canvas.itemconfig(obj.destframe.canvas_image_id, image=obj.thumb)
            gui.after_idle(execute_after)
            
        "In memory"
        if obj.thumb:
            load_thumb(obj.thumb)
            return
        
        "Saved in cache"
        if not obj.id:
            obj.id = gen_id(obj)
        thumbpath = os.path.join(self.data_dir, obj.id+os.extsep+"webp") # make val_thumb_cache reflect the EXTENSION.

        if (os.path.exists(thumbpath)):
            obj.thumbnail = thumbpath
            
            try:
                with Image.open(obj.thumbnail) as image:
                    imagetk = ImageTk.PhotoImage(image)

            except Exception as e:
                print(f"Pillows couldn't load thumbnail from data: {obj.name} : Error: {e}. Trying with pyvips.")
                try:
                    vips_img = pyvips.Image.new_from_file(obj.thumbnail)
                    mode = get_mode(vips_img)
                    buffer = vips_img.write_to_memory()
                    pil_img = Image.frombytes(
                        mode, (vips_img.width, vips_img.height), buffer, "raw")
                    imagetk = ImageTk.PhotoImage(pil_img)
                except Exception as e:
                    print(f"Pyvips couldn't load thumbnail from data: {obj.name} : Error: {e}.")
                    return
            load_thumb(imagetk)
        else:
            "Generate new"
            from imageio import get_reader
            size = gui.thumbnailsize
            if obj.ext in self.video_formats: #Webm, mp4
                try:
                    reader = get_reader(obj.path)
                    pil_img = Image.fromarray(reader.get_data(0))
                    pil_img.thumbnail((size, size))
                except Exception as e:
                    print(f"Couldn't create thumbnail for video: {obj.name} : Error: {e}")
                    return
                finally: 
                    if reader: reader.close()
            else:
                try:
                    pil_img_data = Image.open(obj.path)
                    is_pixel_art = pil_img_data.width <= 256 or pil_img_data.height <= 256 or pil_img_data.mode in ("P",)
                except Exception as e:
                    print(f"PIL couldn't get image dimensions or mode: {obj.name} : Error: {e}.")
                    is_pixel_art = False
                
                try:
                    if is_pixel_art:
                        vips_img = pyvips.Image.new_from_file(obj.path, access="sequential")
                        scale = size / max(vips_img.width, vips_img.height)
                        vips_img = vips_img.resize(scale, kernel="nearest")
                    else:
                        vips_img = pyvips.Image.thumbnail(obj.path, size)
                    buffer = vips_img.write_to_memory()
                    mode = get_mode(vips_img)
                    pil_img = Image.frombytes(
                            mode, (vips_img.width, vips_img.height), buffer, "raw")
                    
                except Exception as e:
                    print(f"Pyvips couldn't create thumbnail: {obj.name} : Error: {e}. Trying with pillows.")
                    try:
                        original_width, original_height = pil_img_data.size
                        aspect_ratio = original_width / original_height

                        if original_width > original_height:
                            new_width = size
                            new_height = int(size / aspect_ratio)
                        else:
                            new_height = size
                            new_width = int(size * aspect_ratio)
                        
                        resampling_filter = Image.Resampling.NEAREST if is_pixel_art else Image.Resampling.LANCZOS
                        pil_img = pil_img_data.resize((new_width, new_height), resampling_filter)
                    except Exception as e:
                        print(f"Pillows couldn't create thumbnail: {obj.name} : Error: {e}")
                        return
                finally:
                    pil_img_data.close()

            if pil_img.mode not in ("RGBA", "RGB"):
                pil_img = pil_img.convert("RGB")

            pil_img.save(thumbpath, format="webp")
            obj.thumbnail = thumbpath

            imagetk = ImageTk.PhotoImage(pil_img)
            load_thumb(imagetk)
    
    def gen_frames(self, obj, dest):
        """
        Generate frames and place inside imagefile. Sets lazy_loading to True until done or exits otherwise.
        If told to exit, clears everything it created, and sets lazy_loading to False.
        Expects frames, frametimes to be empty.

        GIF, WEBP:
            Uses pyvips -> numpy -> PIL -> ImageTk
        MP4, WEBM:
            Uses mediainfo -> av -> (PIL) -> ImageTk: av does the PIL transformation.
        """

        import numpy as np
        import av   # preferred mp4, webm
        import cv2  # secondary
        from pymediainfo import MediaInfo # metadata extractor

        ### test import if they perform bad, mov eelswhere
        
        gui = self.gui
        size = gui.thumbnailsize
        gridmanager = gui.gridmanager
        fileManager = self.fileManager
        path = obj.path

        if self.fileManager.thread_is_exiting or fileManager.shut_down: return
        
        obj.lazy_loading = True
        obj.frames.clear()
        obj.frametimes.clear()
        self.animate.remove_animation(obj)
        if obj.ext in self.video_formats:
            def pick_sampling_rate(duration: float, native_fps: float,min_fps: float = 12.0, max_frames: int = 500, mode: str = "stretch"):
                """
                Calculates desired fps and framecount for the extractors.
                Allows us to crop the video to our desired amount of frames, and allows us to set minimum fps for frametimes.
                pre:
                        float:  duration
                        float:  native_fps
                        float:  min_fps     > 0.0
                        int:    max_frames  > 0
                        str:    mode        = stretch/limit
                """

                if duration == 0.0: 
                    return native_fps if native_fps != 0.0 else min_fps
                cap_rate = max_frames / duration # highest fps if we dont crop duration, but respect max_frames.

                if mode == "stretch": # respect only max_frames.
                    if native_fps * duration <= max_frames:
                        sampling_fps = native_fps # native fps is used if the frames would be under max_frames.
                    else:
                        sampling_fps = cap_rate

                elif mode == "limit": # respect min_fps.
                    if native_fps * duration <= max_frames:
                        sampling_fps = native_fps
                    elif cap_rate >= min_fps: # prefers higher fps before min_fps
                        sampling_fps = cap_rate
                    else:
                        sampling_fps = min_fps # respects min_fps, but will exceed max_frames
                
                # never exceed the video's own frame-rate
                sampling_fps = min(sampling_fps, native_fps)
                
                frame_count = min(max_frames, round(duration * sampling_fps))
                return sampling_fps, frame_count         
            def get_fps_and_duration(path: str):
                mi = MediaInfo.parse(path)
                vt = next((t for t in mi.tracks if t.track_type=="Video"), None)
                gt = next((t for t in mi.tracks if t.track_type=="General"), None)
                if not vt or not gt:
                    raise RuntimeError("Missing tracks")
                # fps
                if vt.frame_rate_num and vt.frame_rate_den:
                    fps = float(vt.frame_rate_num) / float(vt.frame_rate_den)
                else:
                    fps = float(vt.frame_rate or 0) or 24.0
                # duration in seconds
                duration = float(gt.duration or 0) / 1000.0
                return fps, duration                        
            def extract_with_pyav(path: str, timestamps: list, frametime_ms: int):
                """
                Return a list of n randomly-sampled PIL.Image frames from path using PyAV.
                """
                # First, probe duration
                container = av.open(path)
                video_stream = container.streams.video[0]
                time_base = video_stream.time_base
                
                for t in timestamps:
                    container.seek(int(t / time_base), any_frame=False, backward=True, stream=video_stream)
                    for packet in container.demux(video_stream):
                        for frame in packet.decode():
                            if frame.pts * time_base >= t:
                                if fileManager.concurrent_frames >= fileManager.max_concurrent_frames:
                                    self.block.clear()
                                    self.block.wait()
                                    if fileManager.shut_down: return
                                    if (dest and obj.destframe not in gridmanager.displayedset) or (not dest and obj.frame not in gridmanager.displayedset):
                                        gui.after_idle(lambda: (obj.frames.clear, obj.frametimes.clear, setattr(obj, "lazy_loading", False)))
                                        return
                                if fileManager.shut_down: return
                                if self.fileManager.thread_is_exiting:
                                    gui.after_idle(lambda: (obj.frames.clear, obj.frametimes.clear, setattr(obj, "lazy_loading", False)))
                                    return
                                img = frame.to_image()
                                ######tag
                                #img.thumbnail((size, size))
                                original_width, original_height = img.size
                                aspect_ratio = original_width / original_height

                                if original_width > original_height:
                                    new_width = size
                                    new_height = int(size / aspect_ratio)
                                else:
                                    new_height = size
                                    new_width = int(size * aspect_ratio)

                                # Resize the image
                                img = img.resize((new_width, new_height), Image.Resampling.BILINEAR)

                                obj.frames.append(ImageTk.PhotoImage(img))
                                obj.frametimes.append(frametime_ms)
                                if len(obj.frames) == 2:
                                    obj.type = obj.VIDEO
                                    self.animate.add_animation(obj)
                                break
                        else:
                            continue
                        break          
            def extract_with_opencv(path: str, video_fps: float, sampling_fps: float, n: int):
                cap = cv2.VideoCapture(path)

                # 1. Compute timestamps and frame indices based on sampling_fps
                timestamps = [i / sampling_fps for i in range(n)]
                indices = [int(t * video_fps) for t in timestamps]

                frametime_ms = int(round(1000.0 / sampling_fps))

                for idx in indices:
                    cap.set(cv2.CAP_PROP_POS_FRAMES, idx)
                    ret, frame = cap.read()
                    if not ret:
                        continue
                    rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                    pil_img = Image.fromarray(rgb)

                    ######tag
                    #pil_img.thumbnail((size, size))

                    original_width, original_height = pil_img.size
                    aspect_ratio = original_width / original_height

                    if original_width > original_height:
                        new_width = size
                        new_height = int(size / aspect_ratio)
                    else:
                        new_height = size
                        new_width = int(size * aspect_ratio)

                    # Resize the image
                    pil_img = pil_img.resize((new_width, new_height), Image.Resampling.BILINEAR)

                    photo = ImageTk.PhotoImage(pil_img)
                    obj.frames.append(photo)
                    obj.frametimes.append(frametime_ms)
                    if len(obj.frames) == 2:
                        self.animate.add_animation(obj)

                cap.release()
            
            try:
                fps, duration = get_fps_and_duration(path)
                # "limit": maintain min_fps until max_frames is hit. smooth.
                # "stretch": maintain frames under max_frames and show whole video. smoothness not guaranteed.
                # min_fps and max_frames is respected if mode is "limit".
                # max_frames is respected 
                sampling_fps, n = pick_sampling_rate(duration=duration, native_fps=fps, min_fps=24, max_frames=100, mode="limit")
                frametime_ms = int(round(1000.0 / sampling_fps))
                timestamps = [(i / sampling_fps) for i in range(n)]
            
                extract_with_pyav(path, timestamps, frametime_ms)
                #extract_with_opencv(path, fps, sampling_fps, n)
            except Exception as e:
                print("error in gen frames (av)", e)
                gui.after_idle(lambda: (obj.frames.clear, obj.frametimes.clear, setattr(obj, "lazy_loading", False)))
                obj.type = obj.IMAGE
                return

            if len(obj.frames) == 1:
                obj.frames.clear()
                obj.type = obj.IMAGE
                if obj.dest == "":
                    self.gui.gridmanager.change_square_color(obj, self.gui.square_default, outline=True)

        elif obj.ext in self.animated_thumb_formats:
            print(len(obj.frames), len(obj.frametimes), obj.lazy_loading, obj in self.animate.running)
            def vips_to_pillow(vimg):
                if vimg.format != 'uchar': vimg = vimg.cast('uchar')
                if vimg.interpretation != 'srgb': vimg = vimg.colourspace('srgb')
                mem = vimg.write_to_memory()
                h, w, b = vimg.height, vimg.width, vimg.bands
                arr = np.frombuffer(mem, dtype=np.uint8).reshape(h, w, b)
                mode = {1:'L',3:'RGB',4:'RGBA'}.get(b)
                return Image.fromarray(arr)
            def get_frametimes_and_framecount(path, default=100):
                with Image.open(path) as im:
                    durations = []
                    n = im.n_frames
                    for i in range(n):
                        try:
                            im.seek(i)
                        except EOFError:
                            break
                        durations.append(im.info.get('duration', default))
                    return durations, n
            
            obj.frametimes, n = get_frametimes_and_framecount(path)

            obj.type = obj.ANIMATION if n > 1 else obj.IMAGE
            if obj.type == obj.IMAGE: 
                if obj.dest == "": # remove error coloring if static, nothing wrong.
                    self.gui.gridmanager.change_square_color(obj, self.gui.square_default, outline=True)
                return

            try:
                #with open(obj.path,'rb') as f: buf=f.read()
                #base = pyvips.Image.new_from_buffer(buf, "n=-1", access="random")
                base = pyvips.Image.new_from_file(f"{obj.path}[n=-1]", access="random")

                h = base.height // n
                
                for i in range(n):
                    if fileManager.concurrent_frames >= fileManager.max_concurrent_frames:
                        self.block.clear()
                        self.block.wait()
                        if (dest and obj.destframe not in gridmanager.displayedset) or (not dest and obj.frame not in gridmanager.displayedset):
                            gui.after_idle(lambda: (obj.frames.clear, obj.frametimes.clear, setattr(obj, "lazy_loading", False)))
                            return
                    if self.fileManager.thread_is_exiting or fileManager.shut_down:
                        gui.after_idle(lambda: (obj.frames.clear, obj.frametimes.clear, setattr(obj, "lazy_loading", False)))
                        return

                    frame_vips = base.extract_area(0, i * h, base.width, h)
                    scale = min(size / frame_vips.width, size / frame_vips.height)
                    if scale < 1.0:
                        frame_vips = frame_vips.resize(scale)
                    pil_img = vips_to_pillow(frame_vips)

                    obj.frames.append(ImageTk.PhotoImage(pil_img))
                    if len(obj.frames) == 2: 
                        self.animate.add_animation(obj)
            except Exception as e:
                obj.type = obj.IMAGE
                gui.after_idle(lambda: (obj.frames.clear, obj.frametimes.clear, setattr(obj, "lazy_loading", False)))
                print(f"{obj.truncated_filename}..{obj.ext}: Error in frame generation for grid: {e}")
                return

        obj.lazy_loading = False

    def generate(self, imgfiles, dest=False):
        from concurrent.futures import ThreadPoolExecutor
 
        def multithread(dest):
            if self.gen_thread != None:
                self.gen_thread.join()

            self.gen_thread = self.new_thread
            self.fileManager.thread_is_exiting = False
            self.block.clear()

            gui.manage_lines(clear=True)

            static = [(x, dest, x.truncated_filename == "...") for x in imgfiles
                       if x not in self.animate.running] # True/False flag on whether gen_thumb needs to call gen_name as well.
            combined = [x for x in imgfiles 
                        if (x.ext in self.animated_thumb_formats or x.ext in self.video_formats) 
                        and x.type != Imagefile.IMAGE
                        and not (x.lazy_loading == False and x.frames and x.frametimes and len(x.frames) == len(x.frametimes))] # Ignore objs with old, full frame and frametime data.

            with ThreadPoolExecutor(max_workers=max(1,self.threads-2), thread_name_prefix="thumbs") as executor:
                futures = []
                for obj, dest, name in static:
                    if self.fileManager.thread_is_exiting or fileManager.shut_down:
                        break  # Cancel *before* submitting more
                    futures.append(executor.submit(self.gen_thumb, obj, dest, name)) #name is for filename truncation, done along the thumbnail.

                for f in futures:
                    if self.fileManager.thread_is_exiting or fileManager.shut_down:
                        return  # Stop waiting if we're exiting
                    f.result()  # will raise if the task failed

            gui.manage_lines(f"Thumbnails generated in: {timer.stop()}")
            if self.mem: gui.manage_lines(f"Private Line: {self.mem}")

            timer.start()

            for x in combined: 
                self.gui.gridmanager.change_square_color(x, "purple", outline=True)                

            with ThreadPoolExecutor(max_workers=max(1,2), thread_name_prefix="frames") as executor:
                futures = []
                for obj in combined:
                    if self.fileManager.thread_is_exiting or fileManager.shut_down:
                        break  # Cancel *before* submitting more
                    if obj.ext in self.animated_thumb_formats:
                        self.gui.gridmanager.change_square_color(obj, "red", outline=True)
                        
                    futures.append(executor.submit(self.gen_frames, obj, dest))

                for f in futures:
                    if self.fileManager.thread_is_exiting or fileManager.shut_down:
                        return  # Stop waiting if we're exiting
                    f.result()  # will raise if the task failed

            gui.manage_lines(f"Thumbframes generated in: {timer.stop()}"); timer.start()

        fileManager = self.fileManager
        timer = fileManager.timer
        gui = self.gui

        if gui.current_view.get() == "Show Assigned" or dest:
            imgfiles = list(imgfiles)[::-1]

        #if self.gen_thread != None and self.gen_thread.is_alive():
            #self.fileManager.thread_is_exiting = True # tells the thread to stop its processes
            #self.block.set() # exiting + stop blocking = exit, wipe frames?

        self.new_thread = Thread(target=multithread, args=(dest,), name="Gen thread", daemon=True)
        self.new_thread.start()

class Animate:
    def __init__(self, fileManager):
        self.fileManager = fileManager
        self.gui = fileManager.gui
        self.gridmanager = self.gui.gridmanager

        self.running = set() # refs

    def add_animation(self, obj):
        """
        Save ref of the running loop.
        One loop per animation.

        Start animating obj in all visible frames (gridsquares referenced by obj.frame, obj.destframe)
        Two methods to reduce boolean checks. We change the bg twice using flags.
        lazy: Check for conditions to change bg.
        loop: Only check for exit.
        Maybe overkill & bad readability, but hundreds of times a second builds up.
        """
        gui = self.gui
        def lazy(obj):
            instances = [f for f in (obj.frame, obj.destframe) if f]
            if not instances:
                obj.frames.clear(); obj.frametimes.clear()
                self.remove_animation(obj)
                return

            if not obj.lazy_loading:
                self.gridmanager.change_square_color(obj, self.gui.square_outline, outline=True)
                self.gridmanager.change_square_color(obj, self.gui.square_default, fill=True)
                loop(obj) # Non threaded
            elif len(obj.frames) > obj.index:
                for x in instances:
                    x.canvas.itemconfig(x.ids["img"], image=obj.frames[obj.index])
                obj.index = (obj.index + 1) % len(obj.frames)
                gui.after(obj.frametimes[obj.index], lazy, obj)
            else: 
                gui.after(obj.delay, lazy, obj)
        def loop(obj):
            instances = [f for f in (obj.frame, obj.destframe) if f]

            if not instances or len(obj.frames) <= 1: # not visible/no frames
                obj.frames.clear(); obj.frametimes.clear()
                self.remove_animation(obj)
                return
            
            if len(obj.frames) > obj.index:
                for x in instances:
                    x.canvas.itemconfig(x.ids["img"], image=obj.frames[obj.index])
                obj.index = (obj.index + 1) % len(obj.frames)
                gui.after(obj.frametimes[obj.index], loop, obj)

        if    obj in self.running: return 
        else: self.running.add(obj)

        self.gridmanager.change_square_color(obj, "orange", outline=True)
        
        obj.index = 0
        lazy(obj)

    def remove_animation(self, obj):
        """
        Delete ref of the running loop.
        Allows animation to be readded.
        """
        if obj in self.running:
            self.running.remove(obj)
    
class Timer:
    def __init__(self):
        self.creation_time = None
    def start(self):
        self.creation_time = perf_counter()
    def stop(self):
        current_time = perf_counter()
        elapsed_time = current_time - self.creation_time
        return f"{elapsed_time:.3f} s"

if __name__ == '__main__':
    mainclass = SortImages()
